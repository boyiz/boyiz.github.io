<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>谷粒商城 | One Blog</title><meta name="keywords" content="谷粒商城"><meta name="author" content="BOYIZ"><meta name="copyright" content="BOYIZ"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="环境安装 安装CentOS CentOS安装docker docker安装redis docker安装mysql docker安装rabbitmq  .gitignore文件123456789101112131415161718target&#x2F;pom.xml.tagpom.xml.releaseBackuppom.xml.versionsBackuppom.xml.nextrelease.prope">
<meta property="og:type" content="article">
<meta property="og:title" content="谷粒商城">
<meta property="og:url" content="https://boyiz.github.io/2022/07/25/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/index.html">
<meta property="og:site_name" content="One Blog">
<meta property="og:description" content="环境安装 安装CentOS CentOS安装docker docker安装redis docker安装mysql docker安装rabbitmq  .gitignore文件123456789101112131415161718target&#x2F;pom.xml.tagpom.xml.releaseBackuppom.xml.versionsBackuppom.xml.nextrelease.prope">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://fastly.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg2.png">
<meta property="article:published_time" content="2022-07-24T16:00:00.000Z">
<meta property="article:modified_time" content="2022-10-11T05:45:02.674Z">
<meta property="article:author" content="BOYIZ">
<meta property="article:tag" content="谷粒商城">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://fastly.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg2.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://boyiz.github.io/2022/07/25/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="baidu-site-verification" content="codeva-Bl44Rd3gtj"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?625e0d8c5b448d8c4f6b06ba3033e652";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-WB8FK3ZNXT"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-WB8FK3ZNXT');
</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: BOYIZ","link":"链接: ","source":"来源: One Blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '谷粒商城',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-10-11 13:45:02'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.jsdelivr.net/gh/boyiz/OSS@main/img/avatar.JPG" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://fastly.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg2.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">One Blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">谷粒商城</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-07-24T16:00:00.000Z" title="发表于 2022-07-25 00:00:00">2022-07-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-10-11T05:45:02.674Z" title="更新于 2022-10-11 13:45:02">2022-10-11</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">30.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>116分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="谷粒商城"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h2><ul>
<li>安装CentOS</li>
<li>CentOS安装docker</li>
<li>docker安装redis</li>
<li>docker安装mysql</li>
<li>docker安装rabbitmq</li>
</ul>
<h2 id="gitignore文件"><a href="#gitignore文件" class="headerlink" title=".gitignore文件"></a>.gitignore文件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">target/</span><br><span class="line">pom.xml.tag</span><br><span class="line">pom.xml.releaseBackup</span><br><span class="line">pom.xml.versionsBackup</span><br><span class="line">pom.xml.next</span><br><span class="line">release.properties</span><br><span class="line">dependency-reduced-pom.xml</span><br><span class="line">buildNumber.properties</span><br><span class="line">.mvn/timing.properties</span><br><span class="line"># https://github.com/takari/maven-wrapper#usage-without-binary-jar</span><br><span class="line">.mvn/wrapper/maven-wrapper.jar</span><br><span class="line"></span><br><span class="line">**/mvnw</span><br><span class="line">**/mvnw.cmd</span><br><span class="line">**/.mvn</span><br><span class="line">**/target</span><br><span class="line">**/.gitignore</span><br><span class="line">.idea</span><br></pre></td></tr></table></figure>

<h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><ul>
<li>商品服务product </li>
<li>存储服务ware </li>
<li>订单服务order </li>
<li>优惠券服务coupon </li>
<li>用户服务member</li>
</ul>
<p>​					每个模块导入web和openFeign </p>
 <img src="https://raw.githubusercontent.com/boyiz/OSS/main/img/image-20220725215351802.png" alt="image-20220725215351802" style="zoom:50%;" />

<h3 id="父模块创建pox-xml"><a href="#父模块创建pox-xml" class="headerlink" title="父模块创建pox.xml"></a>父模块创建pox.xml</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">    &lt;groupId&gt;com.boyiz.gulimall&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;gulimall&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;name&gt;gulimall&lt;/name&gt;</span><br><span class="line">    &lt;description&gt;gulimall聚合服务&lt;/description&gt;</span><br><span class="line">    &lt;packaging&gt;pom&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line">    &lt;modules&gt;</span><br><span class="line">        &lt;module&gt;gulimall-coupon&lt;/module&gt;</span><br><span class="line">        &lt;module&gt;gulimall-member&lt;/module&gt;</span><br><span class="line">        &lt;module&gt;gulimall-order&lt;/module&gt;</span><br><span class="line">        &lt;module&gt;gulimall-product&lt;/module&gt;</span><br><span class="line">        &lt;module&gt;gulimall-ware&lt;/module&gt;</span><br><span class="line">        &lt;module&gt;renren-fast&lt;/module&gt;</span><br><span class="line">        &lt;module&gt;renren-generator&lt;/module&gt;</span><br><span class="line">        &lt;module&gt;gulimall-common&lt;/module&gt;</span><br><span class="line">        后续模块自行添加...</span><br><span class="line">    &lt;/modules&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>

<h3 id="逆向生成mapper，dao，entity，controller，service"><a href="#逆向生成mapper，dao，entity，controller，service" class="headerlink" title="逆向生成mapper，dao，entity，controller，service"></a>逆向生成mapper，dao，entity，controller，service</h3><p>git clone <a target="_blank" rel="noopener" href="https://gitee.com/renrenio/renren-generator.git">https://gitee.com/renrenio/renren-generator.git</a></p>
<p>配置application.yml中mysql信息</p>
<p>配置generator.properties</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#代码生成器，配置信息</span><br><span class="line"></span><br><span class="line">#主目录</span><br><span class="line">mainPath=com.boyiz</span><br><span class="line">#包名</span><br><span class="line">package=com.boyiz.gulimall</span><br><span class="line">moduleName=ware</span><br><span class="line">#模块名</span><br><span class="line">author=boyiz</span><br><span class="line">#Email</span><br><span class="line">email=xianpeoplenocome@gmail.com</span><br><span class="line">#表前缀(类名不会包含表前缀)</span><br><span class="line">tablePrefix=wms_</span><br></pre></td></tr></table></figure>

<p>运行RenrenApplication，访问<a href="http://localhost:80，生成代码">http://localhost:80，生成代码</a></p>
<h3 id="创建commom模块"><a href="#创建commom模块" class="headerlink" title="创建commom模块"></a>创建commom模块</h3><p>​		每个微服务的公共依赖、工具类等都在此配置，其他模块引入common。</p>
<ul>
<li>mybatis-plus</li>
<li>lombok</li>
<li>mysql</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">##重要</span><br><span class="line">       &lt;!-- nacos 服务注册--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span><br><span class="line">            &lt;exclusions&gt;</span><br><span class="line">                &lt;exclusion&gt;</span><br><span class="line">                    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">                    &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt;</span><br><span class="line">                &lt;/exclusion&gt;</span><br><span class="line">            &lt;/exclusions&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-loadbalancer&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.0.3&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">      &lt;dependencyManagement&gt;</span><br><span class="line">        &lt;dependencies&gt;</span><br><span class="line">            &lt;dependency&gt;</span><br><span class="line">                &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;2.2.8.RELEASE&lt;/version&gt;</span><br><span class="line">                &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">                &lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">            &lt;/dependency&gt;</span><br><span class="line">        &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/dependencyManagement&gt;</span><br></pre></td></tr></table></figure>

<h3 id="整合Mybatis-plus"><a href="#整合Mybatis-plus" class="headerlink" title="整合Mybatis-plus"></a>整合Mybatis-plus</h3><p>整合mybatis-plus，各模块类同</p>
<ul>
<li><pre><code> 1、导入依赖
</code></pre>
</li>
<li><pre><code> 2、配置
 *      1、配置数据源
        *      1、导入数据库驱动
        *      2、application.yml中配置相关信息
 *      2、配置mybatis-plus
        *      1、使用@MapperScan(&quot;com/boyiz/gulimall/product/dao&quot;)
        *      2、告诉mybatis-plus，sql映射文件位置
</code></pre>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@MapperScan(&quot;com/boyiz/gulimall/product/dao&quot;)</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class GulimallProductApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(GulimallProductApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#application.yml</span><br><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    username: root</span><br><span class="line">    password: root</span><br><span class="line">    url: jdbc:mysql://8.8.8.8:3306/gulimall_pms?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai   #配置数据库地址和各模块对应的数据库名</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">    </span><br><span class="line">mybatis-plus:</span><br><span class="line">  mapper-locations: classpath:/mapper/**/*.xml  #配置各个mapper.xml文件路径</span><br><span class="line">  global-config:</span><br><span class="line">    db-config:</span><br><span class="line">      id-type: auto  #id自增</span><br></pre></td></tr></table></figure>

<h2 id="SpringCloud-Alibaba"><a href="#SpringCloud-Alibaba" class="headerlink" title="SpringCloud Alibaba"></a>SpringCloud Alibaba</h2><h3 id="搭配环境"><a href="#搭配环境" class="headerlink" title="搭配环境"></a>搭配环境</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">在common的pom.xml中加入</span><br><span class="line"># 下面是依赖管理，相当于以后再dependencies里引spring cloud alibaba就不用写版本号， 全用dependencyManagement进行管理</span><br><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">     &lt;dependencies&gt;</span><br><span class="line">         &lt;dependency&gt;</span><br><span class="line">             &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">             &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt;</span><br><span class="line">             &lt;version&gt;2.1.0.RELEASE&lt;/version&gt;</span><br><span class="line">             &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">             &lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">         &lt;/dependency&gt;</span><br><span class="line">     &lt;/dependencies&gt;</span><br><span class="line">&lt;/dependencyManagement&gt;</span><br></pre></td></tr></table></figure>

<h3 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h3><ul>
<li>一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。 作为我们的注册中心和配置中心。</li>
<li><a target="_blank" rel="noopener" href="https://nacos.io/zh-cn/">使用文档</a></li>
</ul>
<p>修改 common中的pom.xml 文件，引入 Nacos Discovery Starter。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>在各模块的application.yml 配置文件中配置 Nacos Server 地址和微服务名称</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: gulimall-coupon  #微服务名称</span><br><span class="line">  datasource:</span><br><span class="line">    username: root</span><br><span class="line">    password: root</span><br><span class="line">    url: jdbc:mysql://8.1.9.1:3306/gulimall_sms?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      discovery:</span><br><span class="line">        server-addr: 39.107.96.120:8848  # Nacos Server 地址</span><br><span class="line"></span><br><span class="line">mybatis-plus:</span><br><span class="line">  mapper-locations: classpath:/mapper/**/*.xml</span><br><span class="line">  global-config:</span><br><span class="line">    db-config:</span><br><span class="line">      id-type: auto</span><br><span class="line"></span><br><span class="line">server:  #服务端口号</span><br><span class="line">  port: 12000</span><br></pre></td></tr></table></figure>

<h4 id="下载安装Nacos-Server"><a href="#下载安装Nacos-Server" class="headerlink" title="下载安装Nacos Server"></a>下载安装Nacos Server</h4><p><a target="_blank" rel="noopener" href="https://github.com/alibaba/nacos">https://github.com/alibaba/nacos</a> 解压运行.cmd或.sh （以standalone模式运行，需修改）</p>
<p> docker启动nacos</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name nacos-waper -e MODE=standalone -p 8848:8848 -p 9848:9848 -p 9849:9849 -d nacos/nacos-server</span><br></pre></td></tr></table></figure>

<h3 id="配置服务注册与发现"><a href="#配置服务注册与发现" class="headerlink" title="配置服务注册与发现"></a>配置服务注册与发现</h3><h4 id="EnableDiscoveryClient"><a href="#EnableDiscoveryClient" class="headerlink" title="@EnableDiscoveryClient"></a>@EnableDiscoveryClient</h4><p>@EnableDiscoveryClient 注解开启服务注册与发现功能</p>
<p>各模块类同</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@MapperScan(&quot;com/boyiz/gulimall/product/dao&quot;)</span><br><span class="line">@SpringBootApplication</span><br><span class="line">@EnableDiscoveryClient  //开启服务注册与发现功能</span><br><span class="line">public class GulimallProductApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(GulimallProductApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>application.yml</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      discovery:</span><br><span class="line">        server-addr: 39.107.96.120:8848</span><br></pre></td></tr></table></figure>

<p>访问 ip:8848&#x2F;nacos，默认账号密码nacos</p>
<img src="https://raw.githubusercontent.com/boyiz/OSS/main/img/image-20220725222809899.png" alt="image-20220725222809899" style="zoom:50%;" />

<h3 id="‼️远程调用测试"><a href="#‼️远程调用测试" class="headerlink" title="‼️远程调用测试"></a>‼️远程调用测试</h3><p>在<code>Spring cloud</code>应用中，当我们要使用<code>feign</code>客户端时，一般要做以下三件事情 :</p>
<p>⚠️<strong>1.使用注解<code>@EnableFeignClients</code>启用<code>feign</code>客户端；</strong></p>
<p>⚠️<strong>2.使用注解<code>@FeignClient</code> 定义<code>feign</code>客户端 ;</strong></p>
<p>⚠️<strong>3.使用注解<code>@Autowired</code>使用上面所定义<code>feign</code>的客户端 ；</strong></p>
<p>远程调用别的服务</p>
<ul>
<li><pre><code> 引入openfeign
</code></pre>
</li>
<li><pre><code> 编写接口，告知springcloud这个接口需要调用远程服务
 *      声明接口的每一个方法是调用的哪个远程服务的哪个请求
</code></pre>
</li>
<li><pre><code> 开启远程调用功能
 *      @EnableFeignClients
        *      自动扫描@FeignClient下的接口
</code></pre>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Feign与注册中心</span><br><span class="line">spring cloud feign</span><br><span class="line"></span><br><span class="line">声明式远程调用</span><br><span class="line">feign是一个声明式的HTTP客户端，他的目的就是让远程调用更加简单。给远程服务发的是HTTP请求。</span><br><span class="line">会员服务想要远程调用优惠券服务，只需要给会员服务里引入openfeign依赖，远程调用其他服务的能力。</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>编写接口，@FeignClient注解，value值的要调用的微服务名称</p>
<p>member下建包feign，新建接口CouponFeignService</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 这是一个声明式远程调用</span><br><span class="line"> * @FeignClient</span><br><span class="line"> * gulimall-coupon 表示要调用的微服务名称，同各模块yml中的application name</span><br><span class="line"> */</span><br><span class="line">⚠️2</span><br><span class="line">@FeignClient(&quot;gulimall-coupon&quot;)  //在此表示member远程调用coupon服务</span><br><span class="line">public interface CouponFeignService &#123;</span><br><span class="line">    @RequestMapping(&quot;/coupon/coupon/member/list&quot;)   //要补全membercoupon()方法路径</span><br><span class="line">    public R membercoupon();     //CouponController中membercoupon()方法</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">##MemberController.java</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;member/member&quot;)</span><br><span class="line">public class MemberController &#123;</span><br><span class="line">    ⚠️3</span><br><span class="line">    @Autowired</span><br><span class="line">    CouponFeignService couponFeignService;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/coupons&quot;)</span><br><span class="line">    public R test() &#123;</span><br><span class="line">        MemberEntity memberEntity = new MemberEntity();</span><br><span class="line">        memberEntity.setNickname(&quot;ZS&quot;);</span><br><span class="line">        R membercoupons = couponFeignService.membercoupon();</span><br><span class="line">        return R.ok().put(&quot;member&quot;, memberEntity).put(&quot;coupons&quot;, membercoupons.get(&quot;coupon&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">##CouponController.java</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;coupon/coupon&quot;)</span><br><span class="line">public class CouponController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private CouponService couponService;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/member/list&quot;)</span><br><span class="line">    public R membercoupon() &#123;</span><br><span class="line">        CouponEntity couponEntity = new CouponEntity();</span><br><span class="line">        couponEntity.setCouponName(&quot;100 - 10&quot;);</span><br><span class="line">        return R.ok().put(&quot;coupon&quot;, Arrays.asList(couponEntity));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@SpringBootApplication</span><br><span class="line">⚠️1</span><br><span class="line">###注解@EnableFeignClients告诉框架扫描所有使用注解@FeignClient定义的feign客户端</span><br><span class="line">@EnableFeignClients(basePackages = &quot;com.boyiz.gulimall.member.feign&quot;)  </span><br><span class="line">@EnableDiscoveryClient</span><br><span class="line">public class GulimallMemberApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(GulimallMemberApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动服务，进入<a target="_blank" rel="noopener" href="http://localhost:8000/member/member/coupons">http://localhost:8000/member/member/coupons</a><img src="https://raw.githubusercontent.com/boyiz/OSS/main/img/image-20220725224941728.png" alt="image-20220725224941728" style="zoom:50%;" /></p>
<h3 id="Nacos作为配置中心"><a href="#Nacos作为配置中心" class="headerlink" title="Nacos作为配置中心"></a>Nacos作为配置中心</h3><p>首先，修改 pom.xml 文件，引入 Nacos Config Starter。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>在模块创建 bootstrap.properties 配置文件中配置 Nacos Config 元数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring.application.name=gulimall-coupon   ##应用名</span><br><span class="line">spring.cloud.nacos.config.server-addr=127.0.0.1:8848  ##配置中心地址</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>启动 Nacos Server 并在配置管理中添加配置</p>
<p>​		DataId默认规则：应用名.properties </p>
 <img src="https://raw.githubusercontent.com/boyiz/OSS/main/img/image-20220726093602943.png" alt="image-20220726093602943" style="zoom:50%;" />

<p>给应用名.properties 中添加配置</p>
 <img src="https://raw.githubusercontent.com/boyiz/OSS/main/img/image-20220726093751036.png" alt="image-20220726093751036" style="zoom:50%;" />

<p>服务动态获取配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@RefreshScope：动态获取并刷新配置</span><br><span class="line">@Value(&quot;$&#123;配置项名&#125;&quot;)：获取到配置</span><br><span class="line"></span><br><span class="line">@RefreshScope</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;coupon/coupon&quot;)</span><br><span class="line">public class CouponController &#123;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;coupon.user.name&#125;&quot;)</span><br><span class="line">    private String name;</span><br><span class="line">    @Value(&quot;$&#123;coupon.user.age&#125;&quot;)</span><br><span class="line">    private Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置中心和配置文件中共有的项优先使用配置中心的内容</p>
<h4 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h4><ul>
<li><p>命名空间:  用于进行配置隔离。</p>
<ul>
<li><p>默认：public（保留空间）默认新增的所有配置都在public中</p>
</li>
<li><p>开发、测试、生产等环境，利用命名空间来做配置隔离</p>
<ul>
<li><img src="https://raw.githubusercontent.com/boyiz/OSS/main/img/image-20220726095003882.png" alt="image-20220726095003882" style="zoom:50%;" />
</li>
<li><p>默认使用public空间中的配置，如需改动在bootstrap.properties 配置文件中设置namespace</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring.application.name=gulimall-coupon</span><br><span class="line">spring.cloud.nacos.config.server-addr=39.107.96.120:8848</span><br><span class="line">##使用命名空间ID</span><br><span class="line">spring.cloud.nacos.config.namespace=5b6ed27a-f032-4578-83cb-6d3de4318e3f</span><br></pre></td></tr></table></figure></li>
<li><p>在微服务之间互相隔离配置，为每一个微服务创建自己的命名空间，只加载自己命名空间下的所有配置</p>
<img src="https://raw.githubusercontent.com/boyiz/OSS/main/img/image-20220726095721395.png" alt="image-20220726095721395"  />

<ul>
<li><p>bootstrap.properties 配置文件中设置namespace</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.cloud.nacos.config.namespace=14c37bfc-16e4-4a98-a1fa-3692dabe484d</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>配置集：一组相关或者不相关的配置项的集合称为配置集。</p>
</li>
<li><p>配置集ID：&#x3D;DataId，类似文件名。</p>
</li>
<li><p>配置分组</p>
<ul>
<li><p>默认所有配置集都属于DEFAULT_GROUP</p>
<ul>
<li><p>可以自定义1111，618，1212</p>
</li>
<li><p>bootstrap.properties 配置文件中设置namespace</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.cloud.nacos.config.group=1111</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>每个微服务创建自己的命名空间，使用配置分组区分环境：dev，test，proc</p>
</li>
</ul>
<h4 id="加载多配置集"><a href="#加载多配置集" class="headerlink" title="加载多配置集"></a>加载多配置集</h4><p>将application.yml拆分为三个配置集<br><img src="https://raw.githubusercontent.com/boyiz/OSS/main/img/image-20220726103519268.png" alt="image-20220726103519268" style="zoom:50%;" /></p>
<p>在bootstrap.properties 配置文件中设置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">spring.application.name=gulimall-coupon</span><br><span class="line">spring.cloud.nacos.config.server-addr=ip:8848</span><br><span class="line"></span><br><span class="line">spring.cloud.nacos.config.namespace=14c37bfc-16e4-4a98-a1fa-3692dabe484d</span><br><span class="line">spring.cloud.nacos.config.group=coupon</span><br><span class="line"></span><br><span class="line">spring.cloud.nacos.config.extension-configs[0].data-id=datasource.yml</span><br><span class="line">spring.cloud.nacos.config.extension-configs[0].group=dev</span><br><span class="line">spring.cloud.nacos.config.extension-configs[0].refresh=true</span><br><span class="line"></span><br><span class="line">spring.cloud.nacos.config.extension-configs[1].data-id=mybatis.yml</span><br><span class="line">spring.cloud.nacos.config.extension-configs[1].group=dev</span><br><span class="line">spring.cloud.nacos.config.extension-configs[1].refresh=true</span><br><span class="line"></span><br><span class="line">spring.cloud.nacos.config.extension-configs[2].data-id=other.yml</span><br><span class="line">spring.cloud.nacos.config.extension-configs[2].group=dev</span><br><span class="line">spring.cloud.nacos.config.extension-configs[2].refresh=true</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="服务配置"><a href="#服务配置" class="headerlink" title="服务配置"></a>服务配置</h4><p>GulimallGatewayApplication</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">网关服务，端口88，所有api都访问此端口，配合nacos完成路由选择与路径重写</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      routes:</span><br><span class="line">#配置各个服务的路由与路径重写      </span><br><span class="line">        - id: product_route</span><br><span class="line">          uri: lb://gulimall-product</span><br><span class="line">          predicates:</span><br><span class="line">            - Path=/api/product/**</span><br><span class="line">          filters:</span><br><span class="line">            - RewritePath=/api/(?&lt;segment&gt;.*), /$\&#123;segment&#125;  #把api删掉</span><br><span class="line">        - id: thirdparty_route</span><br><span class="line">          uri: lb://gulimall-thirdparty</span><br><span class="line">          predicates:</span><br><span class="line">            - Path=/api/thirdparty/**</span><br><span class="line">          filters:</span><br><span class="line">            - RewritePath=/api/thirdparty/(?&lt;segment&gt;.*), /$\&#123;segment&#125;  #把api删掉</span><br><span class="line">        - id: admin_route</span><br><span class="line">          uri: lb://renren-fast  #lb: 负载均衡，通过项目名进行请求</span><br><span class="line">          predicates:</span><br><span class="line">            - Path=/api/**  #前端项目都用 /api  /设置低优先级（往后放），否则在前会先过滤所有请求</span><br><span class="line">#  目前配置 http://localhost:88/api/captcha.jpg</span><br><span class="line">#  实际路由后 http://renren-fast:8080/api/captcha.jpg</span><br><span class="line">#  真正路径 http://localhost:8080/renren-fast/api/captcha.jpg</span><br><span class="line">          filters:</span><br><span class="line">            - RewritePath=/api/(?&lt;segment&gt;.*), /renren-fast/$\&#123;segment&#125;</span><br><span class="line"></span><br><span class="line">            #以下为 跨域配置</span><br><span class="line">      globalcors:</span><br><span class="line">        cors-configurations:</span><br><span class="line">          &#x27;[/**]&#x27;:</span><br><span class="line">            allow-credentials: true</span><br><span class="line">            allowedOriginPatterns: &#x27;*&#x27;</span><br><span class="line">            allowedMethods: &#x27;*&#x27;</span><br><span class="line">            allowedHeaders: &#x27;*&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>GulimallProductApplication</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">产品服务，端口10000</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: gulimall-product</span><br><span class="line">  datasource:</span><br><span class="line">    username: root</span><br><span class="line">    password: </span><br><span class="line">    url: jdbc:mysql://8.8.8.8:3306/gulimall_pms?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      discovery:</span><br><span class="line">        server-addr: 8.8.8.8:8848</span><br><span class="line">  main:</span><br><span class="line">    lazy-initialization: true  #springboot2.6开始，默认禁止循环依赖</span><br><span class="line">  jackson:</span><br><span class="line">    date-format: yyyy-MM-dd HH:mm:ss  //配置时间格式</span><br><span class="line"></span><br><span class="line">mybatis-plus:</span><br><span class="line">  mapper-locations: classpath:/mapper/**/*.xml</span><br><span class="line">  global-config:</span><br><span class="line">    db-config:</span><br><span class="line">      id-type: auto</span><br><span class="line">      logic-delete-value: 1</span><br><span class="line">      logic-not-delete-value: 0</span><br><span class="line"></span><br><span class="line">server:</span><br><span class="line">  port: 10000</span><br><span class="line">logging:</span><br><span class="line">  level:</span><br><span class="line">    com.boyiz.gulimall: debug  #设置com.boyiz.gulimall包下所有都是debug级别</span><br><span class="line">alibaba:     #aliyun OSS设置</span><br><span class="line">  cloud:</span><br><span class="line">    access-key: </span><br><span class="line">    secret-key: </span><br><span class="line">    oss:</span><br><span class="line">      endpoint: </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="SpringCloud-OpenFeign"><a href="#SpringCloud-OpenFeign" class="headerlink" title="SpringCloud OpenFeign"></a>SpringCloud OpenFeign</h2><p>导入依赖</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line"> #增加 spring cloutd的依赖：       </span><br><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt;</span><br><span class="line">            &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">            &lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/dependencyManagement&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Feign-Client"><a href="#Feign-Client" class="headerlink" title="Feign Client"></a>Feign Client</h3><h4 id="EnableFeignClients"><a href="#EnableFeignClients" class="headerlink" title="@EnableFeignClients"></a>@EnableFeignClients</h4><ul>
<li>开启远程调用功能</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">## 在主类上增加注解 @EnableFeignClients </span><br><span class="line">@MapperScan(&quot;com/boyiz/gulimall/product/dao&quot;)</span><br><span class="line">@SpringBootApplication</span><br><span class="line">@EnableDiscoveryClient</span><br><span class="line">⚠️//开启远程调用功能，basePackages指定了要扫描声明了Feign客户端的接口。</span><br><span class="line">@EnableFeignClients(basePackages = &quot;com.boyiz.gulimall.product.feign&quot;)</span><br><span class="line">public class GulimallProductApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(GulimallProductApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="FeignClient"><a href="#FeignClient" class="headerlink" title="@FeignClient"></a>@FeignClient</h4><ul>
<li>表明要调用哪个服务</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">## 在product包下新建feign包，创建CouponFeignService.java</span><br><span class="line"></span><br><span class="line">@FeignClient(&quot;gulimall-coupon&quot;) //调用gulimall-coupon模块的服务</span><br><span class="line">public interface CouponFeignService &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 此方法调用gulimall-coupon远程服务</span><br><span class="line">     * 调用服务中的 @PostMapping(&quot;coupon/spubounds/save&quot;) 这个请求</span><br><span class="line">     * @param spuBoundTo</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @PostMapping(&quot;coupon/spubounds/save&quot;)  //此处要填写 对应服务controller 完整路径</span><br><span class="line">    R saveSpuBounds(@RequestBody SpuBoundTo spuBoundTo);</span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;coupon/skufullreduction/saveinfo&quot;)</span><br><span class="line">    R saveSkuReduction(@RequestBody SkuReductionTo skuReductionTo);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 流程：</span><br><span class="line">     *  在SpuInfoServiceImpl 实现中，调用 couponFeignService.saveSpuBounds(spuBoundTo);</span><br><span class="line">     *  1、@RequestBody将spuBoundTo 转为Json</span><br><span class="line">     *  2、找到gulimall-coupon远程服务，给 coupon/spubounds/save 发送请求</span><br><span class="line">     *      同时将Json放在请求体中</span><br><span class="line">     *  3、对方服务接收到请求，@RequestBody 将Json转换为实体</span><br><span class="line">     *  ⚠️只要Json数据模型互相兼容，双方服务无需使用同一个TO</span><br><span class="line">     */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Service(&quot;spuInfoService&quot;)</span><br><span class="line">public class SpuInfoServiceImpl extends ServiceImpl&lt;SpuInfoDao, SpuInfoEntity&gt; implements SpuInfoService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    CouponFeignService couponFeignService; //实现类中自动注入，调用其方法。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="JSR303"><a href="#JSR303" class="headerlink" title="JSR303"></a>JSR303</h2><ul>
<li>参数校验</li>
</ul>
<p><img src="https://raw.githubusercontent.com/boyiz/OSS/main/img/c2cad.jpeg" alt="在这里插入图片描述"></p>
<p>引入依赖</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>在实体类中使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package com.boyiz.gulimall.product.entity;</span><br><span class="line">@Data</span><br><span class="line">@TableName(&quot;pms_brand&quot;)</span><br><span class="line">public class BrandEntity implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">	@NotNull(message = &quot;修改必须指定ID&quot;,groups = &#123;UpdateGroup.class&#125;)  //JSR303分组校验</span><br><span class="line">	@Null(message = &quot;新增无需指定ID&quot;,groups = &#123;AddGroup.class&#125;)</span><br><span class="line">	@TableId</span><br><span class="line">	private Long brandId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Controller 中需要校验的参数Bean前添加 @Valid 开启校验功能，紧跟在校验的Bean后添加一个BindingResult，BindingResult封装了前面Bean的校验结果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@PostMapping(&quot;/&quot;)</span><br><span class="line">public Result save (@Valid User user , BindingResult bindingResult)  &#123;</span><br><span class="line">		if (bindingResult.hasErrors()) &#123;</span><br><span class="line">    	Map&lt;String , String&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">    	bindingResult.getFieldErrors().forEach( (item) -&gt; &#123;</span><br><span class="line">    	String message = item.getDefaultMessage();</span><br><span class="line">    	String field = item.getField();</span><br><span class="line">    	map.put( field , message );</span><br><span class="line">		&#125;);</span><br><span class="line">      return Result.build( 400 , &quot;非法参数 !&quot; , map);</span><br><span class="line">    &#125;</span><br><span class="line">    return Result.ok();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="分组解决校验"><a href="#分组解决校验" class="headerlink" title="分组解决校验"></a>分组解决校验</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">## 两个空接口</span><br><span class="line">public interface AddGroup &#123;&#125;</span><br><span class="line">public interface UpdateGroup &#123;&#125;</span><br><span class="line"></span><br><span class="line">## 定义校验顺序，如果AddGroup组失败，则UpdateGroup组不会再校验</span><br><span class="line">@GroupSequence(&#123;AddGroup.class, UpdateGroup.class&#125;)</span><br><span class="line">public interface Group &#123;&#125;</span><br><span class="line"></span><br><span class="line">⚠️## controller中要使用 @Validated</span><br><span class="line">@RequestMapping(&quot;/save&quot;)   </span><br><span class="line">public R save(@Validated(&#123;AddGroup.class&#125;) @RequestBody BrandEntity brand)&#123;</span><br><span class="line">		brandService.save(brand);</span><br><span class="line">		return R.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自定义校验注解"><a href="#自定义校验注解" class="headerlink" title="自定义校验注解"></a>自定义校验注解</h3><h4 id="自定义一个校验注解-ListValue"><a href="#自定义一个校验注解-ListValue" class="headerlink" title="自定义一个校验注解@ListValue"></a>自定义一个校验注解@ListValue</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package com.boyiz.common.validator.group;</span><br><span class="line"></span><br><span class="line">@Documented</span><br><span class="line">@Target(&#123;ElementType.METHOD, ElementType.FIELD, ElementType.ANNOTATION_TYPE, ElementType.CONSTRUCTOR, ElementType.PARAMETER, ElementType.TYPE_USE&#125;)</span><br><span class="line">⚠️ @Constraint(validatedBy = &#123;ListValueConstraintValidator.class&#125;)  //指定自定义校验器</span><br><span class="line">@Retention(RUNTIME)</span><br><span class="line"></span><br><span class="line">public @interface ListValue &#123;</span><br><span class="line">		//获取ValidationMessages.properties中的值</span><br><span class="line">    String message() default &quot;&#123;com.boyiz.common.validator.group.ListValue.message&#125;&quot;;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] groups() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends Payload&gt;[] payload() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    int[] vals() default &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">###############################################################################################</span><br><span class="line">一个标注(annotation) 是通过@interface关键字来定义的. 这个标注中的属性是声明成类似方法 的样式的. 根据Bean Validation API 规范的要求：</span><br><span class="line"></span><br><span class="line">message属性, 这个属性被用来定义默认得消息模版, 当这个约束条件被验证失败的时候,通过 此属性来输出错误信息。</span><br><span class="line">groups 属性, 用于指定这个约束条件属于哪(些)个校验组. 这个的默认值必须是Class&lt;?&gt;类型数组。</span><br><span class="line">payload 属性, Bean Validation API 的使用者可以通过此属性来给约束条件指定严重级别. 这个属性并不被API自身所使用。</span><br><span class="line"></span><br><span class="line">除了这三个强制性要求的属性(message, groups 和 payload) 之外, 还添加了一个属性用来指定所要求的值. 此属性的名称vals在annotation的定义中比较特殊, 如果只有这个属性被赋值了的话, 那么, 在使用此annotation到时候可以忽略此属性名称.</span><br><span class="line"></span><br><span class="line">另外, 我们还给这个annotation标注了一些元标注( meta annotatioins)：</span><br><span class="line">@Target(&#123; METHOD, FIELD, ANNOTATION_TYPE &#125;): 表示此注解可以被用在方法, 字段或者 annotation声明上。</span><br><span class="line">@Retention(RUNTIME): 表示这个标注信息是在运行期通过反射被读取的.</span><br><span class="line">@Constraint(validatedBy = ListValueConstraintValidator.class): 指明使用哪个校验器(类) 去校验使用了此标注的元素.</span><br><span class="line">@Documented: 表示在对使用了该注解的类进行javadoc操作到时候, 这个标注会被添加到 javadoc当中.</span><br></pre></td></tr></table></figure>

<p>在 src&#x2F;main&#x2F;resources 目录下创建一个名为 ValidationMessages.properties 的文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.boyiz.common.validator.group.ListValue.message = 必须使用指定数值</span><br></pre></td></tr></table></figure>

<p>在实体类中使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class BrandEntity implements Serializable &#123;</span><br><span class="line">	⚠️ @ListValue(vals=&#123;0,1&#125;,groups = &#123;AddGroup.class, UpdateStatusGroup.class&#125;)</span><br><span class="line">	private Integer showStatus;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="创建约束校验器"><a href="#创建约束校验器" class="headerlink" title="创建约束校验器"></a>创建约束校验器</h4><ul>
<li>@Constraint(validatedBy &#x3D; ListValueConstraintValidator.class): 指明使用哪个校验器(类) 去校验使用了此标注的元素.</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class ListValueConstraintValidator implements ConstraintValidator&lt;ListValue, Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private Set&lt;Integer&gt; set = new HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    //初始化方法</span><br><span class="line">    @Override</span><br><span class="line">    public void initialize(ListValue constraintAnnotation) &#123;</span><br><span class="line">        //ConstraintValidator.super.initialize(constraintAnnotation);</span><br><span class="line">        int[] vals = constraintAnnotation.vals();</span><br><span class="line"></span><br><span class="line">        for (int val : vals) &#123;</span><br><span class="line">            set.add(val);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //判断是否教研成功</span><br><span class="line">    /**</span><br><span class="line">     * @param integer   需要校验的值</span><br><span class="line">     * @param constraintValidatorContext</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">     </span><br><span class="line">    @Override</span><br><span class="line">    public boolean isValid(Integer integer, ConstraintValidatorContext constraintValidatorContext) &#123;</span><br><span class="line">        return set.contains(integer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ElasticSearch"><a href="#ElasticSearch" class="headerlink" title="ElasticSearch"></a>ElasticSearch</h2><ul>
<li>Elastic 的底层是开源库 Lucene。但是，你没法直接用 Lucene，必须自己写代码去调用它的接口。Elastic 是 Lucene 的封装，提供了 REST API 的操作接口，开箱即用。</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html">官方文档</a><br><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/foreword_id.html">官方中文</a><br>[社区中文](<a target="_blank" rel="noopener" href="https://es.xiaoleilu.com/index.html">https://es.xiaoleilu.com/index.html</a> <a target="_blank" rel="noopener" href="http://doc.codingdict.com/elasticsearch/0/">http://doc.codingdict.com/elasticsearch/0/</a>)</li>
</ul>
<h3 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h3><p>下载镜像文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull elasticsearch:7.4.2 存储和检索数据 </span><br><span class="line">docker pull kibana:7.4.2 可视化检索数据</span><br></pre></td></tr></table></figure>

<p>创建实例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /mydata/elasticsearch/config</span><br><span class="line">mkdir -p /mydata/elasticsearch/data</span><br><span class="line">echo &quot;http.host: 0.0.0.0&quot; &gt;&gt; /mydata/elasticsearch/config/elasticsearch.yml</span><br><span class="line">chmod -R 777 /mydata/elasticsearch/  #保证权限</span><br><span class="line"></span><br><span class="line">docker run --name elasticsearch -p 9200:9200 -p 9300:9300 \</span><br><span class="line">-e &quot;discovery.type=single-node&quot; \</span><br><span class="line">-e ES_JAVA_OPTS=&quot;-Xms64m -Xmx512m&quot; \</span><br><span class="line">-v /mydata/elasticsearch/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml \ </span><br><span class="line">-v /mydata/elasticsearch/data:/usr/share/elasticsearch/data \</span><br><span class="line">-v /mydata/elasticsearch/plugins:/usr/share/elasticsearch/plugins \</span><br><span class="line">-d elasticsearch:7.4.2</span><br><span class="line"></span><br><span class="line">特别注意:</span><br><span class="line">-e ES_JAVA_OPTS=&quot;-Xms64m -Xmx256m&quot; 测试环境下，设置 ES 的初始内存和最大内存，否则导致过大启动ES失败。</span><br></pre></td></tr></table></figure>

<p>安装Kibana</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run --name kibana -e ELASTICSEARCH_HOSTS=http://192.168.56.10:9200 -p 5601:5601 \</span><br><span class="line">-d kibana:7.4.2</span><br><span class="line"></span><br><span class="line">http://192.168.56.10:9200 改为自己虚拟机/服务器的地址</span><br></pre></td></tr></table></figure>


<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><img src="https://raw.githubusercontent.com/boyiz/OSS/main/img/image-20220804185224560.png" alt="image-20220804185224560" style="zoom:50%;" />

<h4 id="Index-索引"><a href="#Index-索引" class="headerlink" title="Index(索引)"></a>Index(索引)</h4><p>动词，相当于 MySQL 中的 insert;</p>
<p>名词，相当于 MySQL 中的 Database 2、Type(类型)</p>
<h4 id="Type-类型-已弃用"><a href="#Type-类型-已弃用" class="headerlink" title="Type(类型) 已弃用"></a>Type(类型) 已弃用</h4><p>在 Index(索引)中，可以定义一个或多个类型。 </p>
<p>类似于 MySQL 中的 Table，每一种类型的数据放在一起;</p>
<h4 id="Document-文档"><a href="#Document-文档" class="headerlink" title="Document(文档)"></a>Document(文档)</h4><p>保存在某个索引(Index)下，某种类型(Type)的一个数据(Document)，文档是 JSON 格式，Document 就像是 MySQL 中的某个 Table 里面的内容;</p>
<h4 id="Field-字段"><a href="#Field-字段" class="headerlink" title="Field(字段)"></a>Field(字段)</h4><p>每行数据有多个字段<code>field</code>，表示多列</p>
<h4 id="倒排索引-机制"><a href="#倒排索引-机制" class="headerlink" title="倒排索引 机制"></a>倒排索引 机制</h4><p>Elasticsearch 中的索引实际上就是所谓的倒排索引，它是所有搜索引擎工作的机制。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">假如在ES中存在这样三条记录：</span><br><span class="line">&#123;</span><br><span class="line">	&quot;_id&quot;: 1,</span><br><span class="line">	&quot;log&quot;: &quot;Oscar fourteen&quot;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">	&quot;_id&quot;: 2,</span><br><span class="line">	&quot;log&quot;: &quot;Tom fourteen kinds flowers&quot;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">	&quot;_id&quot;: 3,</span><br><span class="line">	&quot;log&quot;: &quot;Oscar fourteen flowers&quot;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<table><thead><tr><th>Term</th><th>Posting list</th></tr></thead><tbody><tr><td>Oscar</td><td>[1, 3]</td></tr><tr><td>fourteen</td><td>[1, 2, 3]</td></tr><tr><td>flowers</td><td>[2, 3]</td></tr><tr><td>kinds</td><td>[2]</td></tr><tr><td>Tom</td><td>[2]</td></tr></tbody></table>

<h4 id="集群的概念"><a href="#集群的概念" class="headerlink" title="集群的概念"></a>集群的概念</h4><ol>
<li>节点Node: 一个Elasticsearch实例，即为一个节点</li>
<li>集群Cluster: 一个或者多个节点共同协作，即组成一个集群<ol>
<li>集群中所有的节点具有相同的cluster.name</li>
<li>集群中的一个节点会被选举为主节点master，临时管理集群级别的变更，如新增或删除节点，新建或删除索引等</li>
<li>集群中每个节点都知道文档存在于哪个节点上，每个节点都可以转发请求到真正存储数据的节点上</li>
<li>作为用户，我们可以访问任意节点（称作请求节点），请求节点负责收集各节点返回的数据，并聚合、处理后返回客户端</li>
</ol>
</li>
</ol>
<p>集群状态</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用/_cluster/health接口，可以获取当前集群的状态信息</span><br></pre></td></tr></table></figure>

<h4 id="分词"><a href="#分词" class="headerlink" title="分词"></a>分词</h4><ul>
<li>一个 <strong>tokenizer</strong>(分词器)接收一个字符流，将之分割为独立的 <strong>tokens</strong>(词元，通常是独立的单词)，然后输出 <strong>tokens</strong> 流。</li>
<li>例如，whitespace <strong>tokenizer</strong> 遇到空白字符时分割文本。它会将文本 “<strong>Quick brown fox!</strong>“ 分割为 [<strong>Quick</strong>, <strong>brown</strong>, <strong>fox!</strong>]。该 <strong>tokenizer</strong>(分词器)还负责记录各个 <strong>term</strong>(词条)的顺序或 <strong>position</strong> 位置(用于 <strong>phrase</strong> 短语和 <strong>word proximity</strong> 词近邻查询)，以及 <strong>term</strong>(词条)所代表的原始 <strong>word</strong>(单词)的 <strong>start</strong> (起始)和 <strong>end</strong>(结束)的 <strong>character offsets</strong>(字符偏移量)(用于高亮显示搜索的内容)。<strong>Elasticsearch</strong> 提供了很多内置的分词器，可以用来构建 custom analyzers(自定义分词器)。</li>
</ul>
<h5 id="ik分词器"><a href="#ik分词器" class="headerlink" title="ik分词器"></a>ik分词器</h5><p>注意:不能用默认 elasticsearch-plugin install xxx.zip 进行自动安装</p>
<p><a target="_blank" rel="noopener" href="https://github.com/medcl/elasticsearch-analysis-ik/releases">对应es版本进行安装</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">进入elasticsearch挂载的plugins目录</span><br><span class="line">对压缩包进行解压</span><br></pre></td></tr></table></figure>

<p>自定义分词器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">修改ik插件目录中的 IKAnalyzer.cfg.xml</span><br><span class="line"> 	xxx/plugins/ik/config/IKAnalyzer.cfg.xml</span><br><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE properties SYSTEM &quot;http://java.sun.com/dtd/properties.dtd&quot;&gt; </span><br><span class="line">&lt;properties&gt;</span><br><span class="line">	&lt;comment&gt;IK Analyzer 扩展配置&lt;/comment&gt; </span><br><span class="line">	&lt;!--用户可以在这里配置自己的扩展字典 --&gt; </span><br><span class="line">	&lt;entry key=&quot;ext_dict&quot;&gt;&lt;/entry&gt;</span><br><span class="line">	&lt;!--用户可以在这里配置自己的扩展停止词字典--&gt; </span><br><span class="line">	&lt;entry key=&quot;ext_stopwords&quot;&gt;&lt;/entry&gt; </span><br><span class="line">	&lt;!--用户可以在这里配置远程扩展字典 --&gt;</span><br><span class="line">	⚠️&lt;entry key=&quot;remote_ext_dict&quot;&gt; http://192.168.128.130/fenci/myword.txt &lt;/entry&gt; </span><br><span class="line">	&lt;!--用户可以在这里配置远程扩展停止词字典--&gt;</span><br><span class="line">	&lt;!-- &lt;entry key=&quot;remote_ext_stopwords&quot;&gt;words_location&lt;/entry&gt; --&gt;</span><br><span class="line">&lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">然后重启 es 服务器</span><br><span class="line">更新完成后，es 只会对新增的数据用新词分词。历史数据是不会重新分词的。如果想要历史数据重新分词。需要执行:</span><br><span class="line">POST my_index/_update_by_query?conflicts=proceed</span><br></pre></td></tr></table></figure>

<h3 id="Elasticsearch-Rest-Client"><a href="#Elasticsearch-Rest-Client" class="headerlink" title="Elasticsearch-Rest-Client"></a><strong>Elasticsearch-Rest-Client</strong></h3><p>9300: TCP</p>
<ul>
<li>spring-data-elasticsearch:transport-api.jar;<ul>
<li>springboot版本不同，<strong>transport-api.jar</strong>不同，不能适配es版本</li>
<li>7.x已经不建议使用，8以后就要废弃</li>
</ul>
</li>
</ul>
<p>9200: HTTP</p>
<ul>
<li><p>JestClient : 非官方，更新慢</p>
</li>
<li><p>RestTemplate: 模拟发HTTP请求，ES很多操作需要自己封装，麻烦</p>
</li>
<li><p>HttpClient: 同上</p>
</li>
<li><p>Elasticsearch-Rest-Client : 官方RestClient，封装了ES操作，API层次分明，上手简单</p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/client/java-rest/current/java-rest-high.html">选择 Elasticsearch-Rest-Client(elasticsearch-rest-high-level-client)</a> </p>
<p>SpingBoot整合使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">##依赖导入 </span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;elasticsearch-rest-high-level-client&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;7.4.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>编写配置，在容器中注入一个RestHighLevelClient</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class ElasticSearchConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public RestHighLevelClient esRestClient() &#123;</span><br><span class="line">        RestHighLevelClient client = new RestHighLevelClient(</span><br><span class="line">                RestClient.builder(new HttpHost(&quot;39.107.96.120&quot;, 9200, &quot;http&quot;)));</span><br><span class="line">        return client;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static final RequestOptions COMMON_OPTIONS;</span><br><span class="line">    static &#123;</span><br><span class="line">        RequestOptions.Builder builder = RequestOptions.DEFAULT.toBuilder();</span><br><span class="line">        // builder.addHeader(&quot;Authorization&quot;, &quot;Bearer &quot; + TOKEN);</span><br><span class="line">        // builder.setHttpAsyncResponseConsumerFactory(</span><br><span class="line">        //         new HttpAsyncResponseConsumerFactory</span><br><span class="line">        //                 .HeapBufferedResponseConsumerFactory(30 * 1024 * 1024 * 1024));</span><br><span class="line">        COMMON_OPTIONS = builder.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>_cat</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET /_cat/nodes :查看所有节点 </span><br><span class="line">GET /_cat/health : 查看 es 健康状况 </span><br><span class="line">GET /_cat/master :查看主节点</span><br><span class="line">GET /_cat/indices :查看所有索引，相当于show databases</span><br></pre></td></tr></table></figure>

<p>索引一个文档(保存)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PUT customer/external/1</span><br><span class="line">&#123;</span><br><span class="line">&quot;name&quot;: &quot;John Doe&quot;</span><br><span class="line">&#125;</span><br><span class="line">⚠️注意</span><br><span class="line">PUT 和 POST 都可以，</span><br><span class="line">POST新增，如果不指定id，会自动生成id。指定id 就会修改这个数据，并新增版本号。</span><br><span class="line">PUT可以新增可以修改。PUT必须指定id；由于PUT需要指定id，我们一般都用来做修改操作，不指定id会报错。</span><br></pre></td></tr></table></figure>

<p>查询文档</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET customer/external/1</span><br></pre></td></tr></table></figure>

<p>更新文档</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">POST customer/external/1/_update</span><br><span class="line">&#123;</span><br><span class="line">	&quot;doc&quot;:&#123;</span><br><span class="line">	&quot;name&quot;: &quot;John Doew&quot;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line">或者</span><br><span class="line">POST customer/external/1 </span><br><span class="line">&#123;</span><br><span class="line">	&quot;name&quot;: &quot;John Doe2&quot; </span><br><span class="line">&#125;</span><br><span class="line">或者 </span><br><span class="line">PUT customer/external/1 </span><br><span class="line">&#123;</span><br><span class="line">	&quot;name&quot;: &quot;John Doe&quot; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">不同: </span><br><span class="line">POST 操作会对比源文档数据，如果相同不操作，文档version不增加;</span><br><span class="line">PUT 操作总会将数据重新保存并增加 version 版本;</span><br><span class="line">带_update 对比元数据如果一样就不进行任何操作。 </span><br><span class="line">根据场景;</span><br><span class="line">	对于大并发更新，不带 update</span><br><span class="line">	对于大并发查询偶尔更新，带 update 对比更新，重新计算分配规则。</span><br><span class="line">	</span><br><span class="line">更新同时增加属性</span><br><span class="line">POST customer/external/1/_update </span><br><span class="line">&#123;</span><br><span class="line">	&quot;doc&quot;: &#123; &quot;name&quot;: &quot;Jane Doe&quot;, &quot;age&quot;: 20 &#125; </span><br><span class="line">&#125;</span><br><span class="line">PUT 和 POST 不带_update 也可以</span><br></pre></td></tr></table></figure>

<p>删除文档&amp;索引</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DELETE customer/external/1</span><br><span class="line">DELETE customer</span><br></pre></td></tr></table></figure>

<p>bulk 批量 API</p>
<ul>
<li>bulk API 以此按顺序执行所有的 action(动作)。如果一个单个的动作因任何原因而失败， 它将继续处理它后面剩余的动作。当 bulk API 返回时，它将提供每个动作的状态(与发送的顺序相同)，所以您可以检查是否一个指定的动作是不是失败了。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">POST customer/external/_bulk </span><br><span class="line">&#123;&quot;index&quot;:&#123;&quot;_id&quot;:&quot;1&quot;&#125;&#125;</span><br><span class="line">&#123;&quot;name&quot;: &quot;John Doe&quot; &#125; </span><br><span class="line">&#123;&quot;index&quot;:&#123;&quot;_id&quot;:&quot;2&quot;&#125;&#125;</span><br><span class="line">&#123;&quot;name&quot;: &quot;Jane Doe&quot; &#125;</span><br><span class="line">语法格式：</span><br><span class="line">&#123; action: &#123; metadata &#125;&#125;</span><br><span class="line">&#123; request body &#125;</span><br><span class="line">#两行为一对</span><br><span class="line">&#123; action: &#123; metadata &#125;&#125;</span><br><span class="line">&#123; request body &#125;</span><br></pre></td></tr></table></figure>

<h2 id="JVM性能监控"><a href="#JVM性能监控" class="headerlink" title="JVM性能监控"></a>JVM性能监控</h2><img src="https://raw.githubusercontent.com/boyiz/OSS/main/img/image-20220804194708021.png" alt="image-20220804194708021" style="zoom:50%;" />

<p>虚拟机：VM Stack</p>
<ul>
<li>描述的是JAVA方法执行的内存模型，每个方法在执行的时候都会创建一个栈帧， 用于存储局部变量表，操作数栈，动态链接，方法接口等信息</li>
<li>局部变量表存储了编译期可知的各种基本数据类型、对象引用</li>
<li>线程请求的栈深度不够会报StackOverflowError异常</li>
<li>栈动态扩展的容量不够会报OutOfMemoryError异常</li>
<li>虚拟机栈是线程隔离的，即每个线程都有自己独立的虚拟机栈</li>
</ul>
<p>本地方法：Native Stack</p>
<ul>
<li>本地方法栈类似于虚拟机栈，只不过本地方法栈使用的是本地方法</li>
</ul>
<p>堆：Heap</p>
<ul>
<li>几乎所有的对象实例都在堆上分配内存</li>
</ul>
<p><img src="https://raw.githubusercontent.com/boyiz/OSS/main/img/image-20220804194946320.png" alt="image-20220804194946320"></p>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><ul>
<li>所有的对象实例以及数组都要在堆上分配。堆是垃圾收集器管理的主要区域，也被称为“GC 堆”;也是我们优化最多考虑的地方。</li>
</ul>
<p>堆可以细分为:</p>
<ul>
<li><p>新生代</p>
<ul>
<li>Eden空间</li>
<li>FromSurvivor空间 </li>
<li>ToSurvivor空间</li>
</ul>
</li>
<li><p>老年代</p>
</li>
<li><p>永久代&#x2F;元空间</p>
<ul>
<li>Java8 以前永久代，受 jvm 管理，java8 以后元空间，直接使用物理内存。因此， 默认情况下，元空间的大小仅受本地内存限制。</li>
</ul>
</li>
</ul>
<p>垃圾回收</p>
<img src="https://raw.githubusercontent.com/boyiz/OSS/main/img/image-20220804195154406.png" alt="image-20220804195154406" style="zoom:50%;" />

<h3 id="jvisualvm"><a href="#jvisualvm" class="headerlink" title="jvisualvm"></a><strong>jvisualvm</strong></h3><p>Java9以后不自带，需自行下载Visual VM，监控内存泄露，跟踪垃圾回收，执行时内存、cpu 分析，线程分析…</p>
<p>安装插件Visual GC方便查看 <strong>gc</strong></p>
<ul>
<li>启动，工具，插件</li>
<li>如果503错误解决:<ul>
<li>打开网址<a target="_blank" rel="noopener" href="https://visualvm.github.io/pluginscenters.html">https://visualvm.github.io/pluginscenters.html</a> </li>
<li>cmd查看自己的jdk版本，找到对应的复制查询出来的链接，并重新设置上即可。</li>
</ul>
</li>
</ul>
<h2 id="压力测试"><a href="#压力测试" class="headerlink" title="压力测试"></a>压力测试</h2><h3 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h3><ul>
<li>响应时间(Response Time: RT)<ul>
<li>响应时间指用户从客户端发起一个请求开始，到客户端接收到从服务器端返回的响应结束，整个过程所耗费的时间。</li>
</ul>
</li>
<li>HPS(Hits Per Second) :每秒点击次数，单位是次&#x2F;秒。</li>
<li>TPS(Transaction per Second):系统每秒处理交易数，单位是笔&#x2F;秒。</li>
<li>QPS(Query per Second):系统每秒处理查询次数，单位是次&#x2F;秒。<ul>
<li>对于互联网业务中，如果某些业务有且仅有一个请求连接，那么 TPS&#x3D;QPS&#x3D;HPS，一般情况下用 TPS 来衡量整个业务流程，用 QPS 来衡量接口查询次数，用 HPS 来表示对服务器单击请求。</li>
</ul>
</li>
<li>无论TPS、QPS、HPS,此指标是衡量系统处理能力非常重要的指标，越大越好，根据经验，一般情况下:<ul>
<li>金融行业:1000TPS~50000TPS，不包括互联网化的活动 </li>
<li>保险行业:100TPS~100000TPS，不包括互联网化的活动 </li>
<li>制造行业:10TPS~5000TPS </li>
<li>互联网电子商务:10000TPS~1000000TPS </li>
<li>互联网中型网站:1000TPS~50000TPS </li>
<li>互联网小型网站:500TPS~10000TPS</li>
</ul>
</li>
<li>最大响应时间(Max Response Time) 指用户发出请求或者指令到系统做出反应(响应) 的最大时间。</li>
<li>最少响应时间(Mininum ResponseTime)指用户发出请求或者指令到系统做出反应(响 应)的最少时间。</li>
<li>90%响应时间(90% Response Time) 是指所有用户的响应时间进行排序，第 90%的响应时间。</li>
<li>从外部看，性能测试主要关注如下三个指标<ul>
<li><pre><code>吞吐量:每秒钟系统能够处理的请求数、任务数。
</code></pre>
</li>
<li><pre><code>响应时间:服务处理一个请求或一个任务的耗时。
</code></pre>
</li>
<li><pre><code>错误率:一批请求中结果出错的请求所占比例。
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="JMeter-Address-Already-in-use-错误解决"><a href="#JMeter-Address-Already-in-use-错误解决" class="headerlink" title="JMeter Address Already in use 错误解决"></a>JMeter Address Already in use 错误解决</h3><p>windows 本身提供的端口访问机制的问题。<br> Windows 提供给 TCP&#x2F;IP 链接的端口为 1024-5000，并且要四分钟来循环回收他们。就导致 我们在短时间内跑大量的请求时将端口占满了。</p>
<ol>
<li><p>cmd 中，用 regedit 命令打开注册表</p>
</li>
<li><p>在 HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters 下，</p>
<ol>
<li>右击 parameters，添加一个新的 DWORD，名字为 MaxUserPort</li>
<li>然后双击 MaxUserPort，输入数值数据为 65534，基数选择十进制(如果是分布式运 行的话，控制机器和负载机器都需要这样操作哦)</li>
</ol>
</li>
<li><p>修改配置完毕之后记得重启机器才会生效</p>
</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://support.microsoft.com/zh-cn/help/196271/when-you-try-to-connect-from-tcp-ports-greater-than-5000-you-receive-t">官方地址</a><br> TCPTimedWaitDelay:30</p>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><ul>
<li>哪些数据适合放入缓存?<ul>
<li>即时性、数据一致性要求不高的</li>
<li>访问量大且更新频率不高的数据(读多，写少)</li>
</ul>
</li>
</ul>
 <img src="https://raw.githubusercontent.com/boyiz/OSS/main/img/image-20220804195917761.png" alt="image-20220804195917761" style="zoom:50%;" />

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">data = cache.load(id);//从缓存加载数据 </span><br><span class="line">if(data == null)&#123;</span><br><span class="line">	data = db.load(id);//从数据库加载数据</span><br><span class="line">	cache.put(id,data);//保存到 cache 中 </span><br><span class="line">&#125;</span><br><span class="line">return data;</span><br></pre></td></tr></table></figure>

<p>⚠️注意：在开发中，凡是放入缓存中的数据我们都应该指定过期时间，使其可以在系统即使没有主动更新数据也能自动触发数据加载进缓存的流程；避免业务崩溃导致的数据永久不一致问题。</p>
<h3 id="整合Redis"><a href="#整合Redis" class="headerlink" title="整合Redis"></a>整合Redis</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--引入redis--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">		&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">配置文件中配置redis信息</span><br><span class="line">spring:</span><br><span class="line">  redis:</span><br><span class="line">    host: *.*.*.*</span><br><span class="line">    port: 6379</span><br></pre></td></tr></table></figure>

<h4 id="使用-RedisTemplate-操作-redis"><a href="#使用-RedisTemplate-操作-redis" class="headerlink" title="使用 RedisTemplate 操作 redis"></a>使用 RedisTemplate 操作 redis</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void testRedis()&#123;</span><br><span class="line">    ValueOperations&lt;String, String&gt; ops = stringRedisTemplate.opsForValue();</span><br><span class="line">    //保存</span><br><span class="line">    ops.set(&quot;hello&quot;,&quot;world&quot;);</span><br><span class="line">    //查询</span><br><span class="line">    String hello = ops.get(&quot;hello&quot;);</span><br><span class="line">    System.out.println(hello);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="缓存失效问题"><a href="#缓存失效问题" class="headerlink" title="缓存失效问题"></a>缓存失效问题</h3><h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><ul>
<li><p>缓存穿透是指<u>查询一个 <em><strong>一定不存在</strong></em> 的数据</u>，由于缓存是不命中，将去查询数据库，但是数据库也无此记录，我们没有将这次查询的 null 写入缓存，这将导致这个不存在的数据每次 请求都要到存储层去查询，失去了缓存的意义。 在流量大时，可能DB就挂掉了，要是有人利用不存在的key频繁攻击我们的应用，这就是漏洞。</p>
</li>
<li><p>解决：</p>
<p>缓存空结果、并且设置短的过期时间</p>
</li>
</ul>
<h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><ul>
<li>缓存雪崩是指在我们设置缓存时采用了相同的过期时间，导致 *<u>缓存在某一时刻同时失效</u>*，请求全部转发到 DB，DB 瞬时压力过重雪崩。</li>
<li>解决:<br>原有的失效时间基础上增加一个随机值，比如 1-5 分钟随机，这样每一个缓存的过期时间的 重复率就会降低，就很难引发集体失效的事件。</li>
</ul>
<h4 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h4><ul>
<li><p>对于一些设置了过期时间的key，如果这些key可能会在某些时间点被超高并发地访问， 是一种非常“热点”的数据。这个时候，需要考虑一个问题 : 如果这个key在大量请求同时进来前正好失效，那么所有对这个 key 的数据查询都落到 db，我们称为缓存击穿。</p>
</li>
<li><p>解决: </p>
<ul>
<li>设置<strong>热点数据不过期</strong>；</li>
<li>加锁，第一个请求的线程可以拿到锁，拿到锁的线程查询到数据之后设置缓存，其他的线程获取锁失败后会等待50ms，然后重新到缓存中获取数据，这样就可以避免大量的请求落到数据库中。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">get</span><span class="params">(key)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> redis.get(key);</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123; <span class="comment">//代表缓存值过期</span></span><br><span class="line">    <span class="comment">//设置3min的超时，防止del操作失败的时候，下次缓存过期一直不能load db</span></span><br><span class="line">    <span class="comment">//key_mutex的值随便设置，加锁的值随便设置都可以</span></span><br><span class="line">      <span class="keyword">if</span> (redis.setnx(key_mutex, <span class="number">1</span>, <span class="number">3</span> * <span class="number">60</span>) == <span class="number">1</span>) &#123;  <span class="comment">//代表设置成功</span></span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">// 查询数据库，并写到缓存，让其他线程可以直接走缓存</span></span><br><span class="line">              value = db.get(key);</span><br><span class="line">              redis.set(key, value, expire_secs);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">// 异常处理</span></span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 释放锁</span></span><br><span class="line">              redis.del(key_mutex);</span><br><span class="line">            &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">          <span class="comment">//这个时候代表同时候的其他线程已经load db并回设到缓存了，这时候重试获取缓存值即可</span></span><br><span class="line">          sleep(<span class="number">50</span>);</span><br><span class="line">          get(key);  <span class="comment">//重试</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> value;      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">上述代码意味着：每个客户端线程请求key的数据，如果在redis中得到了对应的value，直接返回；如果value为空（即数据不在缓存中），则需要进一步查询数据库。此时想查询数据库的线程就要去争夺key的锁，第一个率先得到锁的就会在数据库中得到value并返回，并设置缓存；没有得到锁的则sleep 50ms，然后继续试图从缓存中得到key对应的值，往复循环，直到得到value。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="缓存数据一致性"><a href="#缓存数据一致性" class="headerlink" title="缓存数据一致性"></a>缓存数据一致性</h3><h4 id="保证一致性模式"><a href="#保证一致性模式" class="headerlink" title="保证一致性模式"></a>保证一致性模式</h4><h5 id="双写模式"><a href="#双写模式" class="headerlink" title="双写模式"></a>双写模式</h5><img src="https://raw.githubusercontent.com/boyiz/OSS/main/img/image-20220804200749390.png" alt="image-20220804200749390" style="zoom:50%;" />

<ul>
<li><p>写数据库后，更新缓存。</p>
</li>
<li><p>出现问题：由于卡顿等原因，导致写缓存2在最前，写缓存1在后面，就出现数据不一致。【脏数据问题】</p>
</li>
<li><p>解决方案：</p>
<ul>
<li>① 整个操作加锁。将写数据库和写缓存这段逻辑加锁，同时只有一个线程可以操作。</li>
<li>② 看业务是否允许数据暂时的不一致问题，如果允许，可以不管这个缓存不一致的事情，将数据放入缓存的时候，设置缓存过期时间，只要数据过期了，就会重新从数据库中加载数据。</li>
</ul>
</li>
</ul>
<h5 id="失效模式"><a href="#失效模式" class="headerlink" title="失效模式"></a>失效模式</h5><img src="https://raw.githubusercontent.com/boyiz/OSS/main/img/image-20220804200819221.png" alt="image-20220804200819221" style="zoom:50%;" />

<ul>
<li>写数据库后，删除缓存。</li>
<li>出现问题：一个线程先写数据库db-1，然后删除缓存；另一个线程接着写数据库db-2，还没来得写完，第三个线程就读取了数据库原db-1数据，并更新了缓存，因此数据库中存放的是db-2，而缓存中存放的是db-1。【脏数据问题】</li>
</ul>
<p>无论是双写模式还是失效模式，都会存在缓存不一致的问题。即多个实例同时更新会出事。</p>
<ul>
<li>如果是用户维度数据（订单数据，用户数据），这种并发几率非常小，不用考虑这个问题，缓存数据加上过期时间，每隔一段时间触发读的主动更新即可。</li>
<li>如果是菜单，商品介绍等基础数据，也可以去使用canal订阅binlog方式。</li>
<li>缓存数据 + 过期时间 也足够解决大部分业务对缓存的要求。</li>
<li>通过加锁保证并发读写，写写的时候按顺序排好队，读读无所谓。所以适合使用读写锁。（业务不关系脏数据，允许临时脏数据可忽略）</li>
</ul>
<p>总结：</p>
<ul>
<li>我们能放入缓存的数据本就不应该是实时性、一致性要求超高的。缓存的所有数据都有过期时间，数据过期下一次查询出发主动更新。</li>
<li>读写数据的时候，加上分布式读写锁。</li>
<li>遇到实时性、一致性要求高的数据，就应该查数据库，即使慢点。</li>
</ul>
<p>改进方法</p>
<ul>
<li>分布式读写锁</li>
<li>cananl</li>
</ul>
<h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><h3 id="本地锁"><a href="#本地锁" class="headerlink" title="本地锁"></a>本地锁</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">加锁：只要是同一把锁，就能锁住需要这个锁的所有线程。</span><br><span class="line"></span><br><span class="line">synchronized (this) ：springboot所有的组件在容器中都是单例的。</span><br><span class="line"></span><br><span class="line">本地锁：synchronized，JUC（Lock）只能锁住当前进程；</span><br><span class="line"></span><br><span class="line">在分布式情况下，想要锁住所有，必须使用分布式锁</span><br></pre></td></tr></table></figure>

<h3 id="分布式锁阶段一"><a href="#分布式锁阶段一" class="headerlink" title="分布式锁阶段一"></a>分布式锁阶段一</h3> <img src="https://raw.githubusercontent.com/boyiz/OSS/main/img/image-20220804203807950.png" alt="image-20220804203807950" style="zoom:50%;" />

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">若程序异常导致未删除锁，可能会造成死锁</span><br><span class="line">解决：</span><br><span class="line">	设置锁的过期时间</span><br></pre></td></tr></table></figure>

<h3 id="分布式锁阶段二"><a href="#分布式锁阶段二" class="headerlink" title="分布式锁阶段二"></a>分布式锁阶段二</h3> <img src="https://raw.githubusercontent.com/boyiz/OSS/main/img/image-20220804204049547.png" alt="image-20220804204049547" style="zoom:50%;" />

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">若程序在设置锁过期时间时出现异常，会致死锁</span><br><span class="line">解决：</span><br><span class="line">	上锁和设置过期时间需为原子操作，setnx ex</span><br></pre></td></tr></table></figure>

<h3 id="分布式锁阶段三"><a href="#分布式锁阶段三" class="headerlink" title="分布式锁阶段三"></a>分布式锁阶段三</h3> <img src="https://raw.githubusercontent.com/boyiz/OSS/main/img/image-20220804204605260.png" alt="image-20220804204605260" style="zoom:50%;" />

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">删除锁时自己的锁已过期导致删掉后来加上的非自己的锁</span><br><span class="line">解决：</span><br><span class="line">	占锁的时候，指定为uuid，当匹配是自己锁才删除</span><br></pre></td></tr></table></figure>

<h3 id="分布式锁阶段四"><a href="#分布式锁阶段四" class="headerlink" title="分布式锁阶段四"></a>分布式锁阶段四</h3> <img src="https://raw.githubusercontent.com/boyiz/OSS/main/img/image-20220804205230989.png" alt="image-20220804205230989" style="zoom:50%;" />

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">判断完uuid之后删锁时，锁正好已过期，后来者的锁加上被删掉</span><br><span class="line">解决：</span><br><span class="line">	删除锁必须保证原子性《Lua脚本》</span><br><span class="line">String script = &quot;if redis.call(&#x27;get&#x27;,KEYS[1]) == ARGV[1] then return redis.call(&#x27;del&#x27;,KEYS[1]) else return 0 end&quot;;</span><br><span class="line">Integer lock1 = stringRedisTemplate.execute(new DefaultRedisScript&lt;Integer&gt;(script, Integer.class), Arrays.asList(&quot;lock&quot;), uuid);    </span><br><span class="line">## 示例：http://redis.cn/commands/set.html</span><br></pre></td></tr></table></figure>

<h3 id="分布式锁最终阶段"><a href="#分布式锁最终阶段" class="headerlink" title="分布式锁最终阶段"></a>分布式锁最终阶段</h3> <img src="https://raw.githubusercontent.com/boyiz/OSS/main/img/image-20220804205600130.png" alt="image-20220804205600130" style="zoom:50%;" />

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">保证加锁【占位+过期时间】和删除锁【判断+删除】的原子性。</span><br><span class="line">存在的问题：</span><br><span class="line">	无法完成锁的自动续期，并且所有的加锁解锁操作必须配合lua脚本完成，过于繁琐。</span><br></pre></td></tr></table></figure>

<h3 id="Redisson分布式锁"><a href="#Redisson分布式锁" class="headerlink" title="Redisson分布式锁"></a>Redisson分布式锁</h3><p><a target="_blank" rel="noopener" href="https://github.com/redisson/redisson/wiki/1.-%E6%A6%82%E8%BF%B0">官方文档</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">## 导入依赖</span><br><span class="line">&lt;!-- 使用redisson作为所有分布式锁，分布式对象等功能框架--&gt;</span><br><span class="line">&lt;!-- https://mvnrepository.com/artifact/org.redisson/redisson --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.redisson&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;redisson&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.17.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>编写配置类文件  ——<a target="_blank" rel="noopener" href="https://github.com/redisson/redisson/wiki/2.-%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95">教程</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class MyRedissonConfig &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 所有对Redisson的操作都是通过RedissonClient对象</span><br><span class="line">     * @return</span><br><span class="line">     * @throws IOException</span><br><span class="line">     */</span><br><span class="line">    @Bean(destroyMethod=&quot;shutdown&quot;)</span><br><span class="line">    public RedissonClient redisson() throws IOException &#123;</span><br><span class="line">        //1、创建配置</span><br><span class="line">        Config config = new Config();</span><br><span class="line">        config.useSingleServer().setAddress(&quot;redis://39.107.96.120:6379&quot;);</span><br><span class="line">        //2、根据config创建出RedissonClient实例</span><br><span class="line">        return Redisson.create(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>锁的说明——<a target="_blank" rel="noopener" href="https://github.com/redisson/redisson/wiki/8.-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%92%8C%E5%90%8C%E6%AD%A5%E5%99%A8">官方</a></p>
<h5 id="可重入锁（Reentrant-Lock）"><a href="#可重入锁（Reentrant-Lock）" class="headerlink" title="可重入锁（Reentrant Lock）"></a><strong>可重入锁（Reentrant Lock）</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@ResponseBody</span><br><span class="line">@GetMapping(&quot;/hello&quot;)</span><br><span class="line"> public String hello() &#123;</span><br><span class="line">     //获取一把锁，只要锁的名字相同，就是同一把锁</span><br><span class="line">     RLock lock = redisson.getLock(&quot;my-lock&quot;);</span><br><span class="line">     //加锁</span><br><span class="line">     lock.lock();//阻塞式等待，默认加的锁都是30s的时间</span><br><span class="line">     //1）锁的自动续期，如果业务超长，运行期间自动给锁续上新的30s。不用担心业务时间长，锁自动过期被删除。</span><br><span class="line">     //2）加锁的业务只要运行完成，就不会给当前锁续期，即使不手动解锁，锁默认在30s之后自动删除。</span><br><span class="line"></span><br><span class="line">     //lock.lock(10, TimeUnit.SECONDS);//10s自动解锁，自动解锁时间一定要大于业务执行时间。</span><br><span class="line">     //问题：lock.lock(10, TimeUnit.SECONDS);在锁时间到了以后，不会自动续期。</span><br><span class="line">     //1. 如果我们传递了超时时间，就发送给redis执行脚本，进行占锁，默认超时就是我们指定的时间</span><br><span class="line">     //2. 如果我们未指定超时时间，就使用30 * 1000【lockWatchdogTimeout看门狗的默认时间】</span><br><span class="line">     //    只要占锁成功，就会启动一个定时任务【重新给锁设置过期时间，新的过期时间就是看门狗的默认时间】</span><br><span class="line">     //    internalLockLeaseTime【看门狗的的时间】 / 3 ，也就是10s。每隔10s都会自动再次续期，续成30s</span><br><span class="line"></span><br><span class="line">     //最佳实战：lock.lock(30, TimeUnit.SECONDS);省掉了整个续期操作，手动操作。将解锁时间设大一些 为30s</span><br><span class="line">     try &#123;</span><br><span class="line">         System.out.println(&quot;加锁成功，指定业务代码....&quot; + Thread.currentThread().getId());</span><br><span class="line">         Thread.sleep(30000);</span><br><span class="line">     &#125; catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">     &#125; finally &#123;</span><br><span class="line">         //解锁  假设解锁代码没有运行，redisson会不会出现死锁————不会。</span><br><span class="line">         System.out.println(&quot;释放锁...&quot; + Thread.currentThread().getId() );</span><br><span class="line">         lock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line">     return &quot;hello&quot;;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h5 id="读写锁（ReadWriteLock）"><a href="#读写锁（ReadWriteLock）" class="headerlink" title="读写锁（ReadWriteLock）"></a><strong>读写锁（ReadWriteLock）</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">	 /**</span><br><span class="line">     * 保证一定能读到最新数据，修改期间，写锁是一个排它锁（互斥锁、独享锁），读锁是一个共享锁</span><br><span class="line">     * 写锁没释放读锁必须等待</span><br><span class="line">     * 读 + 读 ：相当于无锁，并发读，只会在Redis中记录好，所有当前的读锁。他们都会同时加锁成功</span><br><span class="line">     * 写 + 读 ：必须等待写锁释放</span><br><span class="line">     * 写 + 写 ：阻塞方式</span><br><span class="line">     * 读 + 写 ：有读锁。写也需要等待</span><br><span class="line">     *    只要有写的锁都必须等待</span><br><span class="line">     */</span><br><span class="line">@ResponseBody</span><br><span class="line">@GetMapping(&quot;/write&quot;)</span><br><span class="line">public String writeValue() &#123;</span><br><span class="line">    RReadWriteLock lock = redisson.getReadWriteLock(&quot;wr-lock&quot;);</span><br><span class="line">    String s = &quot;&quot;;</span><br><span class="line">    RLock rLock = lock.writeLock();//改数据加写锁</span><br><span class="line">    try &#123;</span><br><span class="line">        rLock.lock();</span><br><span class="line">        System.out.println(&quot;写锁加锁成功...&quot; + Thread.currentThread().getId());</span><br><span class="line">        s = UUID.randomUUID().toString();</span><br><span class="line">        Thread.sleep(30000);</span><br><span class="line">        redisTemplate.opsForValue().set(&quot;writeValue&quot;,s);</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        rLock.unlock();</span><br><span class="line">        System.out.println(&quot;写锁释放成功...&quot; + Thread.currentThread().getId());</span><br><span class="line">    &#125;</span><br><span class="line">    return s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@ResponseBody</span><br><span class="line">@GetMapping(&quot;/read&quot;)</span><br><span class="line">public String readValue() &#123;</span><br><span class="line">    RReadWriteLock lock = redisson.getReadWriteLock(&quot;wr-lock&quot;);</span><br><span class="line">    String s = &quot;&quot;;</span><br><span class="line">    RLock rLock = lock.readLock();//读数据加读锁</span><br><span class="line">    try &#123;</span><br><span class="line">        rLock.lock();</span><br><span class="line">        System.out.println(&quot;读锁加锁成功...&quot; + Thread.currentThread().getId());</span><br><span class="line">        Thread.sleep(30000);</span><br><span class="line">        s = redisTemplate.opsForValue().get(&quot;writeValue&quot;);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        rLock.unlock();</span><br><span class="line">        System.out.println(&quot;读锁释放成功...&quot; + Thread.currentThread().getId());</span><br><span class="line">    &#125;</span><br><span class="line">    return s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="信号量（Semaphore）"><a href="#信号量（Semaphore）" class="headerlink" title="信号量（Semaphore）"></a><strong>信号量（Semaphore）</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 车库停车</span><br><span class="line"> * 3车位</span><br><span class="line"> * 信号量也可以做分布式限流</span><br><span class="line"> */</span><br><span class="line">@GetMapping(value = &quot;/park&quot;)</span><br><span class="line">@ResponseBody</span><br><span class="line">public String park() throws InterruptedException &#123;</span><br><span class="line">    RSemaphore park = redisson.getSemaphore(&quot;park&quot;);</span><br><span class="line">    park.acquire();     //获取一个信号、获取一个值,占一个车位</span><br><span class="line">    boolean flag = park.tryAcquire();</span><br><span class="line">    if (flag) &#123;</span><br><span class="line">        //执行业务</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return &quot;error&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return &quot;ok=&gt;&quot; + flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@GetMapping(value = &quot;/go&quot;)</span><br><span class="line">@ResponseBody</span><br><span class="line">public String go() &#123;</span><br><span class="line">    RSemaphore park = redisson.getSemaphore(&quot;park&quot;);</span><br><span class="line">    park.release();     //释放一个信号</span><br><span class="line">    return &quot;ok&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">可以理解为信号量是存储在redis中的一个数字，当这个数字大于0时，即可以调用 release() 方法增加数量，也可以调用 acquire() 方法减少数量，但是当调用 release()之后小于0的话方法就会阻塞，直到数字大于0</span><br></pre></td></tr></table></figure>

<h5 id="闭锁（CountDownLatch）"><a href="#闭锁（CountDownLatch）" class="headerlink" title="闭锁（CountDownLatch）"></a><strong>闭锁（CountDownLatch）</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 放假、锁门</span><br><span class="line"> * 5个班，全部走完，我们才可以锁大门</span><br><span class="line"> * 分布式闭锁</span><br><span class="line"> */</span><br><span class="line">@GetMapping(value = &quot;/lockDoor&quot;)</span><br><span class="line">@ResponseBody</span><br><span class="line">public String lockDoor() throws InterruptedException &#123;</span><br><span class="line">    RCountDownLatch door = redisson.getCountDownLatch(&quot;door&quot;);</span><br><span class="line">    door.trySetCount(5);</span><br><span class="line">    door.await();       //等待闭锁完成</span><br><span class="line">    return &quot;放假了...&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@GetMapping(value = &quot;/gogogo/&#123;id&#125;&quot;)</span><br><span class="line">@ResponseBody</span><br><span class="line">public String gogogo(@PathVariable(&quot;id&quot;) Long id) &#123;</span><br><span class="line">    RCountDownLatch door = redisson.getCountDownLatch(&quot;door&quot;);</span><br><span class="line">    door.countDown();       //计数-1</span><br><span class="line">    return id + &quot;班的人都走了...&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Spring-Cache"><a href="#Spring-Cache" class="headerlink" title="Spring Cache"></a>Spring Cache</h2><ul>
<li>spring从3.1开始定义了Cache、CacheManager接口来统一不同的缓存技术。并支持使用JCache(JSR-107)注解简化开发。</li>
<li>每次调用需要缓存功能的方法时，spring会检查指定参数的指定的目标方法是否已经被调用过；如果有就直接从缓存中获取方法调用后的结果，如果没有就调用方法并缓存结果后返回给用户，下次调用直接从缓存中获取。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 引入SpringCache缓存--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//开启缓存功能</span><br><span class="line">@EnableCaching</span><br><span class="line">public class GulimallProductApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(GulimallProductApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#配置文件中设置</span><br><span class="line">#配置redis作为缓存</span><br><span class="line">spring.cache.type=redis</span><br><span class="line">#设置redis的key的ttl，单位：毫秒</span><br><span class="line">spring.cache.redis.time-to-live= 3600000</span><br></pre></td></tr></table></figure>

<p>编写配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableCaching</span><br><span class="line">public class MyCacheConfig &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 会导致配置文件中的设置失效</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    RedisCacheConfiguration redisCacheConfiguration()&#123;</span><br><span class="line">        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig();</span><br><span class="line">        //设置缓存以Json格式存储</span><br><span class="line">        config = config.serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(new StringRedisSerializer()));</span><br><span class="line">        config = config.serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(new GenericJackson2JsonRedisSerializer()));</span><br><span class="line">        config = config.entryTtl(Duration.ofMillis(300000));//设置失效时间</span><br><span class="line">        config = config.computePrefixWith(CacheKeyPrefix.prefixed(&quot;CACHE_&quot;));//设置前缀</span><br><span class="line">        //默认缓存空值</span><br><span class="line">        return config;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">    /**</span><br><span class="line">     * @CacheEvict:失效模式</span><br><span class="line">     * @Caching:同时进行多种缓存操作</span><br><span class="line">     * @CacheEvict (value = &quot;XXX&quot;,allEntries = true ):删除某个分区下的所有数据，失效模式</span><br><span class="line">     * @同一类型的数据可以指定为同一个分区</span><br><span class="line">     * @CachePut:双写模式</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">//    @Caching(evict = &#123;</span><br><span class="line">//            @CacheEvict(value = &quot;category&quot;, key = &quot;&#x27;getLevel1Categorys&#x27;&quot;),</span><br><span class="line">//            @CacheEvict(value = &quot;category&quot;, key = &quot;&#x27;getCatalogJson&#x27;&quot;)</span><br><span class="line">//    &#125;)</span><br><span class="line"></span><br><span class="line">//    @CacheEvict(value = &quot;category&quot;, key = &quot;&#x27;getLevel1Categorys&#x27;&quot;)</span><br><span class="line">//    @CacheEvict(value = &quot;category&quot;,allEntries = true ) //删除category分区中所有数据</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//    每个缓存数据都需要指定放入哪个名字的缓存中【缓存的分区，按照业务类型分】</span><br><span class="line">//         value:缓存分区名，        key:缓存数据的键,字符串加上单引号,</span><br><span class="line">// ex:key = &quot;&#x27;level1Categorys&#x27;&quot;  ,设置方法名:key = &quot;#root.method.name</span><br><span class="line">1. 每一个需要缓存的数据我们都来指定要放到那个名字的缓存。【缓存的分区（按照业务划分）】</span><br><span class="line">2. @Cacheable(&#123;&quot;category&quot;&#125;)：表示当前方法的结果需要缓存，如果缓存中有，方法不用调用。如果缓存中没有，会调用方法，并将方法的结果放入缓存。</span><br><span class="line">3. 默认行为</span><br><span class="line">     1）如果缓存中有，方法不用调用</span><br><span class="line">     2）key默认自动生成：缓存的名字::SimpleKey []（自动生成key的值）</span><br><span class="line">     3）缓存的value的值：默认使用jdk序列换机制。将序列化后的数据存到redis。</span><br><span class="line">     4）默认ttl时间是-1。</span><br><span class="line">4. 自定义</span><br><span class="line">     1）指定生成缓存使用的key： key属性指定，接收一个SpEL表达式</span><br><span class="line">         SpEL语法详细：https://docs.spring.io/spring-framework/docs/5.3.19-SNAPSHOT/reference/html/integration.html#cache</span><br><span class="line">     2）指定缓存数据的存活时间： 配置文件中修改ttl</span><br><span class="line">     3）将数据保存为json格式：</span><br><span class="line">         查看源码，自定义RedisCacheConfiguration配置类进行修改</span><br><span class="line">@Cacheable(value = &#123;&quot;category&quot;&#125;,key = &quot;#root.method.name&quot;)  </span><br></pre></td></tr></table></figure>

<p><strong>缓存注解的说明</strong>：</p>
<ul>
<li>@Cacheable：触发将数据保存到缓存的操作</li>
<li>@CacheEvict：触发将数据从缓存中删除的操作</li>
<li>@CachePut：不影响方法执行更新缓存</li>
<li>@Caching：组合以上多个操作</li>
<li>@CacheConfig：在类级别共享缓存的相同配置</li>
</ul>
<p>原理说明：【源码分析】</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CacheAutoConfiguration -&gt; RedisCacheConfiguration -&gt;</span><br><span class="line">	自动配置了缓存管理器RedisCacheManager -&gt; 初始化所有的缓存 -&gt; 每个缓存解决使用什么配置</span><br><span class="line">-&gt; 如果redisCacheConfiguration有就用已有的，没有就用默认配置</span><br><span class="line">-&gt; 想改缓存的配置，只需要给容器中放一个RedisCacheConfiguration即可</span><br><span class="line">-&gt; 就会应用到当前 RedisCacheManager管理的所有缓存分区中</span><br></pre></td></tr></table></figure>

<p>SpringCache原理与不足：</p>
<p>1）读模式</p>
<ul>
<li>缓存穿透：查询一个null数据。<ul>
<li>解决方案：缓存空数据，可通过spring.cache.redis.cache-null-values&#x3D;true</li>
</ul>
</li>
<li>缓存击穿：大量并发进来同时查询一个正好过期的数据。<ul>
<li>解决方案：加锁 ? 默认是无加锁的。</li>
<li>使用 sync &#x3D; true 来解决击穿问题，只有@Cacheable有sync</li>
</ul>
</li>
<li>缓存雪崩：大量的key同时过期。<ul>
<li>解决：加随机时间。可通过spring.cache.redis.time-to-live&#x3D;3600000</li>
</ul>
</li>
</ul>
<p>2）写模式：（缓存与数据库一致）</p>
<ul>
<li><p>读写加锁。【适用于读多写少】</p>
</li>
<li><p>引入Canal，感知到MySQL的更新去更新Redis</p>
</li>
<li><p>读多写多，直接去数据库查询就行。</p>
</li>
</ul>
<p>3）总结：</p>
<ul>
<li>常规数据（读多写少，即时性，一致性要求不高的数据，完全可以使用Spring-Cache）</li>
<li>写模式（只要缓存的数据有过期时间就足够了)</li>
<li>特殊数据：特殊设计</li>
</ul>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="初始化线程的-4-种方式"><a href="#初始化线程的-4-种方式" class="headerlink" title="初始化线程的 4 种方式"></a>初始化线程的 4 种方式</h3><ul>
<li>继承Thread</li>
<li>实现Runnable接口</li>
<li>实现Callable接口 + FutureTask</li>
<li>线程池</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadTest &#123;</span><br><span class="line"></span><br><span class="line">    public static ExecutorService service = Executors.newFixedThreadPool(10);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line">        //1、继承Thread</span><br><span class="line">        Thread01 thread01 = new Thread01();</span><br><span class="line">        thread01.start();</span><br><span class="line"></span><br><span class="line">        //2、实现Runnable接口</span><br><span class="line">        Runnable01 runnable01 = new Runnable01();</span><br><span class="line">        new Thread(runnable01).start();</span><br><span class="line"></span><br><span class="line">        //3、实现Callable接口 + FutureTask</span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;&gt;(new Callable01());</span><br><span class="line">        new Thread(futureTask).start();</span><br><span class="line">        Integer integer = futureTask.get();//阻塞等待整个线程执行完成，获取返回结果</span><br><span class="line"></span><br><span class="line">        //4、线程池</span><br><span class="line">        //我们以后业务代码里面，以上三种启动线程的方式都不用。【将所有的多线程异步任务都交给线程池执行】</span><br><span class="line">        //当前系统中池只有一两个，每个异步任务，提交给线程池让他自己去执行就行</span><br><span class="line">        service.execute(new Runnable01());</span><br><span class="line">		</span><br><span class="line">				//原生的线程池</span><br><span class="line">        ThreadPoolExecutor executor = new ThreadPoolExecutor(5,</span><br><span class="line">                200,</span><br><span class="line">                10,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                new LinkedBlockingDeque&lt;&gt;(10000),</span><br><span class="line">                Executors.defaultThreadFactory(),</span><br><span class="line">                new ThreadPoolExecutor.AbortPolicy());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class Thread01 extends Thread &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(&quot;当前线程：&quot;+Thread.currentThread().getId());</span><br><span class="line">            int i = 10 /2;</span><br><span class="line">            System.out.println(&quot;运行结果：&quot; + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class Runnable01 implements Runnable &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(&quot;当前线程：&quot;+Thread.currentThread().getId());</span><br><span class="line">            int i = 10 /2;</span><br><span class="line">            System.out.println(&quot;运行结果：&quot; + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class Callable01 implements Callable&lt;Integer&gt; &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public Integer call() throws Exception &#123;</span><br><span class="line">            System.out.println(&quot;当前线程：&quot;+Thread.currentThread().getId());</span><br><span class="line">            int i = 10 /2;</span><br><span class="line">            System.out.println(&quot;运行结果：&quot; + i);</span><br><span class="line">            return i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">总结：</span><br><span class="line">	方式 1 和方式 2 不能得到返回值，方式3 可以得到返回值。</span><br><span class="line">	方式 1 和方式 2 和方式 3 不利于控制服务器中的线程资源。会导致服务器资源耗尽。</span><br><span class="line">	方式 4 可以控制资源，比较稳定，也可以获取执行结果，并捕获异常。</span><br></pre></td></tr></table></figure>

<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>优点</p>
<ul>
<li><p>降低资源的消耗： 通过重复利用已经创建好的线程降低线程的创建和销毁带来的损耗。</p>
</li>
<li><p>提高响应速度：因为线程池中的线程数没有超过线程池的最大上限时， 有的线程处于等待分配任务的状态， 当任务来时无需创建新的线程就能执行。</p>
</li>
<li><p>提高线程的可管理性：线程池会根据当前系统特点对池内的线程进行优化处理， 减少创建和销毁线程带来的系统开销。 无限的创建和销毁线程不仅消耗系统资源， 还降低系统的稳定性， 使用线程池进行统一分配 。</p>
</li>
</ul>
<h4 id="常见的-4-种线程池"><a href="#常见的-4-种线程池" class="headerlink" title="常见的 4 种线程池"></a>常见的 4 种线程池</h4><ul>
<li>newCachedThreadPool ：创建一个可缓存线程池， 如果线程池长度超过处理需要， 可灵活回收空闲线程， 若无可回收， 则新建线程。</li>
<li>newFixedThreadPool：创建一个定长线程池， 可控制线程最大并发数， 超出的线程会在队列中等待。</li>
<li>newScheduledThreadPool：创建一个定长线程池， 支持定时及周期性任务执行。</li>
<li>newSingleThreadExecutor：创建一个单线程化的线程池， 它只会用唯一的工作线程来执行任务， 保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行</li>
</ul>
<h4 id="线程池七大参数说明"><a href="#线程池七大参数说明" class="headerlink" title="线程池七大参数说明"></a>线程池七大参数说明</h4><ul>
<li>int corePoolSize：核心线程数[一直存在，除非设置allowCoreThreadTimeOut]；线程池创建好以后就准备就绪的线程数量，就等待来接受异步任务去执行。</li>
<li>int maximumPoolSize：最大线程数量；控制资源并发</li>
<li>long keepAliveTime：存活时间；如果当前的线程数量大于核心数量。 释放空闲的线程（keepAliveTime-corePoolSize）。只要线程空闲大于指定的keepAliveTime。</li>
<li>TimeUnit unit：时间单位；</li>
<li>BlockingQueue workQueue：阻塞队列；如果任务有很多，就会将目前多的任务放在队列里面。只要有线程空闲，就会去队列里面取出新的任务继续执行。</li>
<li>ThreadFactory threadFactory：线程的创建工厂；</li>
<li>RejectedExecutionHandler handler：如果队列满了，按照我们指定的拒绝策略拒绝执行任务。</li>
</ul>
<h4 id="线程池工作顺序"><a href="#线程池工作顺序" class="headerlink" title="线程池工作顺序"></a>线程池工作顺序</h4><ol>
<li>线程池创建，准备好 core 数量的核心线程，准备接受任务</li>
<li>新的任务进来，用 core 准备好的空闲线程执行。<ol>
<li>core 满了，就将再进来的任务放入阻塞队列中。空闲的 core 就会自己去阻塞队 列获取任务执行</li>
<li>阻塞队列满了，就直接开新线程执行，最大只能开到 max 指定的数量</li>
<li>max 都执行好了。Max-core 数量空闲的线程会在 keepAliveTime 指定的时间后自动销毁。最终保持到 core 大小</li>
<li>如果线程数开到了 max 的数量，还有新任务进来，就会使用 reject 指定的拒绝策 略进行处理</li>
</ol>
</li>
<li>所有的线程创建都是由指定的 factory 创建的。</li>
</ol>
<blockquote>
<p>面试： 一个线程池 core 7； max 20 ，queue：50，100 并发进来怎么分配？<br>解决：<br>          先有 7 个能直接得到执行，接下来 50 个进入队列排队，在多开 13 个继续执行。现在 70 个 被安排上了。剩下 30 个默认拒绝策略。如果不想抛弃还要执行，可以使用 CallerRunsPolicy 同步方式执行。</p>
</blockquote>
<h4 id="CompletableFuture-异步编排"><a href="#CompletableFuture-异步编排" class="headerlink" title="CompletableFuture 异步编排"></a>CompletableFuture 异步编排</h4><ul>
<li>在 Java 8 中, 新增加了一个包含 50 个方法左右的类: CompletableFuture， 提供了非常强大的Future 的扩展功能， 可以帮助我们简化异步编程的复杂性， 提供了函数式编程的能力， 可以通过回调的方式处理计算结果， 并且提供了转换和组合 CompletableFuture 的方法。CompletableFuture 类实现了 Future 接口， 所以你还是可以像以前一样通过get方法阻塞或者轮询的方式获得结果， 但是这种方式不推荐使用。</li>
<li>CompletableFuture 和 FutureTask 同属于 Future 接口的实现类， 都可以获取线程的执行结果。</li>
</ul>
<h5 id="创建异步操作"><a href="#创建异步操作" class="headerlink" title="创建异步操作"></a><strong>创建异步操作</strong></h5><ol>
<li>runXxxx   没有返回结果</li>
<li>supplyXxx   可以获取返回结果的</li>
<li>Executor  可以传入自定义的线程池， 否则就用默认的线程池 。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadTest &#123;</span><br><span class="line">    public static ExecutorService executor = Executors.newFixedThreadPool(10);</span><br><span class="line">    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line">        CompletableFuture&lt;Void&gt; future = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(&quot;当前线程：&quot; + Thread.currentThread().getId());</span><br><span class="line">            int i = 10 / 2;</span><br><span class="line">            System.out.println(&quot;运行结果：&quot; + i);</span><br><span class="line">        &#125;, executor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法完成后的感知</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class CompletableFutureTest &#123;</span><br><span class="line">    public static ExecutorService service = Executors.newFixedThreadPool(10);</span><br><span class="line">    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line">        CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">             System.out.println(&quot;当前线程：&quot; + Thread.currentThread().getId());</span><br><span class="line">             int i = 10 / 0;</span><br><span class="line">             System.out.println(&quot;运行结果：&quot; + i);</span><br><span class="line">             return i;</span><br><span class="line">         &#125;, executor).whenComplete((res,exception) -&gt; &#123;</span><br><span class="line">             //虽然能得到异常信息，但是没法修改返回数据</span><br><span class="line">             System.out.println(&quot;异步任务成功完成了...结果是：&quot; + res + &quot;异常是：&quot; + exception);</span><br><span class="line">         &#125;).exceptionally(throwable -&gt; &#123;</span><br><span class="line">             //可以感知异常，同时返回默认值</span><br><span class="line">             return 10;</span><br><span class="line">         &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;        </span><br></pre></td></tr></table></figure>

<p><strong>handle，方法完成后的处理</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class CompletableFutureTest &#123;</span><br><span class="line">    public static ExecutorService service = Executors.newFixedThreadPool(10);</span><br><span class="line">    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line">        CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(&quot;当前线程：&quot; + Thread.currentThread().getId());</span><br><span class="line">            int i = 10 / 2;</span><br><span class="line">            System.out.println(&quot;运行结果：&quot; + i);</span><br><span class="line">            return i;</span><br><span class="line">        &#125;, executor).handle((result,thr) -&gt; &#123;</span><br><span class="line">            if (result != null) &#123;</span><br><span class="line">                return result * 2;</span><br><span class="line">            &#125;</span><br><span class="line">            if (thr != null) &#123;</span><br><span class="line">                System.out.println(&quot;异步任务成功完成了...结果是：&quot; + result + &quot;异常是：&quot; + thr);</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p> <strong>线程串行化方法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 1.thenRunAsync：不能获取到上一步的执行结果，无返回值</span><br><span class="line"> * .thenRunAsync(() -&gt; &#123;</span><br><span class="line"> *             System.out.println(&quot;任务2启动了...&quot;);</span><br><span class="line"> *         &#125;, service);</span><br><span class="line"> * 2.thenAcceptAsync：能接收上一步结果，无返回值</span><br><span class="line"> * .thenAcceptAsync(res -&gt; &#123;</span><br><span class="line"> *             System.out.println(&quot;任务2启动了...&quot; + res);</span><br><span class="line"> *         &#125;, service);</span><br><span class="line"> * 3.thenApplyAsync：能接收上一步结果，有返回值</span><br><span class="line"> * .thenApplyAsync(res -&gt; &#123;</span><br><span class="line"> *             System.out.println(&quot;任务2启动了...&quot; + res);</span><br><span class="line"> *             return &quot;hello&quot; + res;</span><br><span class="line"> *         &#125;, service);</span><br><span class="line"> */</span><br><span class="line">public class CompletableFutureTest &#123;</span><br><span class="line">    public static ExecutorService service = Executors.newFixedThreadPool(10);</span><br><span class="line">    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line">    	CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(&quot;当前线程：&quot; + Thread.currentThread().getId());</span><br><span class="line">            int i = 10 / 4;</span><br><span class="line">            System.out.println(&quot;运行结果：&quot; + i);</span><br><span class="line">            return i;</span><br><span class="line">        &#125;, service).thenApplyAsync(res -&gt; &#123;</span><br><span class="line">            System.out.println(&quot;任务2启动了...&quot; + res);</span><br><span class="line">            return &quot;hello&quot; + res;</span><br><span class="line">        &#125;, service);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>两个都完成再执行第三个</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public class CompletableFutureTest &#123;</span><br><span class="line">    public static ExecutorService service = Executors.newFixedThreadPool(10);</span><br><span class="line">    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;Object&gt; future01 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(&quot;plan1：&quot; + Thread.currentThread().getId());</span><br><span class="line">            int i = 10 / 2;</span><br><span class="line">            System.out.println(&quot;plan1_over：&quot; + i);</span><br><span class="line">            return i;</span><br><span class="line">        &#125;, executor);</span><br><span class="line">        CompletableFuture&lt;Object&gt; future02 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(&quot;plan2：&quot; + Thread.currentThread().getId());</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(2000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            int i = 10 / 2;</span><br><span class="line">            System.out.println(&quot;plan2_over：&quot; + i);</span><br><span class="line">            return &quot;hello &quot; + i;</span><br><span class="line">        &#125;, executor);</span><br><span class="line">        </span><br><span class="line">        //组合plan1和plan2，完成plan1和plan2之后开始第三个任务，无法感知结果</span><br><span class="line">        future01.runAfterBothAsync(future02, () -&gt; &#123;</span><br><span class="line">            System.out.println(&quot;plan3_start&quot;);</span><br><span class="line">        &#125;, executor);</span><br><span class="line"></span><br><span class="line">        //可感知结果，    void accept(T t, U u);</span><br><span class="line">        future01.thenAcceptBothAsync(future02, (f1, f2) -&gt; &#123;</span><br><span class="line">            System.out.println(&quot;plan3_start&quot;);</span><br><span class="line">            System.out.println(&quot;plan1 result：&quot; + f1);</span><br><span class="line">            System.out.println(&quot;plan2 result：&quot; + f2);</span><br><span class="line">        &#125;, executor);</span><br><span class="line"></span><br><span class="line">        //再进阶，合并多个任务，可指定返回值</span><br><span class="line">        //        R apply(T t, U u);</span><br><span class="line">        CompletableFuture&lt;String&gt; future03 = future01.thenCombineAsync(future02, (f1, f2) -&gt; &#123;</span><br><span class="line">            System.out.println(&quot;plan3_start&quot;);</span><br><span class="line">            return &quot;result：&quot; + f1 + &quot;--&gt; &quot; + f2;</span><br><span class="line">        &#125;, executor);</span><br><span class="line">        System.out.println(future03.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>完成任意一个</strong>future，执行任务3</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public class CompletableFutureTest &#123;</span><br><span class="line">    public static ExecutorService service = Executors.newFixedThreadPool(10);</span><br><span class="line">    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line">    </span><br><span class="line">        CompletableFuture&lt;Object&gt; future01 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(&quot;plan1：&quot; + Thread.currentThread().getId());</span><br><span class="line">            int i = 10 / 2;</span><br><span class="line">            System.out.println(&quot;plan1_over：&quot; + i);</span><br><span class="line">            return i;</span><br><span class="line">        &#125;, executor);</span><br><span class="line">        CompletableFuture&lt;Object&gt; future02 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(&quot;plan2：&quot; + Thread.currentThread().getId());</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(2000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            int i = 10 / 2;</span><br><span class="line">            System.out.println(&quot;plan2_over：&quot; + i);</span><br><span class="line">            return &quot;hello &quot; + i;</span><br><span class="line">        &#125;, executor);</span><br><span class="line">        </span><br><span class="line">        //不感知结果,无返回值</span><br><span class="line">        future01.runAfterEitherAsync(future02, () -&gt; &#123;</span><br><span class="line">            System.out.println(&quot;plan3_start&quot;);</span><br><span class="line">            //future2设置Thread.sleep()测试效果。</span><br><span class="line">        &#125;,executor);</span><br><span class="line">        //感知结果,无返回值</span><br><span class="line">        future01.acceptEitherAsync(future02, (res) -&gt; &#123;</span><br><span class="line">            System.out.println(&quot;plan3_start&quot;);</span><br><span class="line">            //future2设置Thread.sleep()测试效果。</span><br><span class="line">            System.out.println(&quot;res:&quot;+ res);</span><br><span class="line">        &#125;,executor);</span><br><span class="line">        //感知结果,也有返回值</span><br><span class="line">        CompletableFuture&lt;String&gt; future03 = future01.applyToEitherAsync(future02, (res) -&gt; &#123;</span><br><span class="line">            System.out.println(&quot;plan3_start&quot;);</span><br><span class="line">            //future2设置Thread.sleep()测试效果。</span><br><span class="line">            return res + &quot;  plan3&quot;;</span><br><span class="line">        &#125;, executor);</span><br><span class="line">        System.out.println(future03.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>多任务组合</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class CompletableFutureTest &#123;</span><br><span class="line">    public static ExecutorService service = Executors.newFixedThreadPool(10);</span><br><span class="line">    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line">        CompletableFuture&lt;String&gt; futureImg = CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">            System.out.println(&quot;查询图片信息&quot;);</span><br><span class="line">            return &quot;hello.jpg&quot;;</span><br><span class="line">        &#125;,executor);</span><br><span class="line">        CompletableFuture&lt;String&gt; futureAttr = CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(2000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;查询属性信息&quot;);</span><br><span class="line">            return &quot;黑色 128G&quot;;</span><br><span class="line">        &#125;,executor);</span><br><span class="line">        CompletableFuture&lt;String&gt; futureDesc = CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">            System.out.println(&quot;查询介绍信息&quot;);</span><br><span class="line">            return &quot;Huawei&quot;;</span><br><span class="line">        &#125;,executor);</span><br><span class="line">        </span><br><span class="line">        CompletableFuture&lt;Void&gt; allOf = CompletableFuture.allOf(futureImg, futureAttr, futureDesc);</span><br><span class="line">        allOf.get();    //等待所有结果完成</span><br><span class="line">        System.out.println(&quot;结束。。。&quot;);</span><br><span class="line">        System.out.println(futureImg.get());</span><br><span class="line">        System.out.println(futureAttr.get());</span><br><span class="line">        System.out.println(futureDesc.get());</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;Object&gt; anyOf = CompletableFuture.anyOf(futureImg, futureAttr, futureDesc);</span><br><span class="line">        anyOf.get();    //只要有一个完成</span><br><span class="line">        System.out.println(anyOf.get());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="认证服务"><a href="#认证服务" class="headerlink" title="认证服务"></a>认证服务</h2><h4 id="开通阿里云的短信服务"><a href="#开通阿里云的短信服务" class="headerlink" title="开通阿里云的短信服务"></a>开通阿里云的短信服务</h4><ul>
<li>进入阿里云的短信服务</li>
<li>开通短信服务</li>
<li>申请短信模板，需要等待审核</li>
<li>获取accessKeyID、accessKeySecret、signName、templateCode</li>
</ul>
<h4 id="整合短信服务"><a href="#整合短信服务" class="headerlink" title="整合短信服务"></a>整合短信服务</h4><ol>
<li>引入 spring-cloud-starter-alicloud-oss 依赖</li>
<li>application.properties中配置属性</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line"> cloud:</span><br><span class="line">  alicloud:</span><br><span class="line">   sms:</span><br><span class="line">    access-key-i-d: 阿里云头像下拉选中得到</span><br><span class="line">    access-key-secret: 阿里云头像下拉选中得到</span><br><span class="line">    sign-name: 阿里云申请的签名</span><br><span class="line">    template-code: 阿里云申请的模板</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>封装发送验证码的接口</li>
<li>在测试类中调用接口测试</li>
</ol>
<h4 id="发送验证码并防刷"><a href="#发送验证码并防刷" class="headerlink" title="发送验证码并防刷"></a>发送验证码并防刷</h4><p>要解决的问题：</p>
<ol>
<li>在页面上检查元素时，暴露了验证码的请求路径，那么别人拿到这个请求路径就可以无限制的发送验证码。</li>
<li>尽管我们设置了60秒之后才能再次发送验证码，但是只要刷新页面，还是可以重新发送验证码，因此需要设置验证码防刷功能，即使刷新页面仍然需要等待60秒之后才能再次发送验证码。</li>
<li>验证码在注册时需要再次校验，因此生成验证码之后，需要重新存起来</li>
<li>我们需要设置验证码的过期时间，即验证码在5分钟内有效，即设置redis的过期时间</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;/sendcode&quot;)</span><br><span class="line">public R sendCode(@RequestParam(&quot;phone&quot;) String phone) &#123;</span><br><span class="line">    //TODO 1、接口防刷</span><br><span class="line">    String redisCode = redisTemplate.opsForValue().</span><br><span class="line">          get(AuthServerConstant.SMS_CODE_CACHE_PREFIX + phone);</span><br><span class="line">    if (!StringUtils.isEmpty(redisCode)) &#123;</span><br><span class="line">        Long time = Long.parseLong(redisCode.split(&quot;_&quot;)[1]);</span><br><span class="line">        if (System.currentTimeMillis() - time &lt; 60000) &#123;</span><br><span class="line">            return R.error(BizCodeEnume.SMS_CODE_EXCEPTION.getCode(), </span><br><span class="line">               BizCodeEnume.SMS_CODE_EXCEPTION.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //2、验证码的再次校验，redis： key-》phone，value-》code</span><br><span class="line">    //sms:code:17777777777 -&gt; 123456</span><br><span class="line">    //加上系统时间判断防止被刷验证码</span><br><span class="line">    String code = UUID.randomUUID().toString().substring(0, 6);</span><br><span class="line">    //redis缓存验证码，防止同一个phone在60s内再次发送</span><br><span class="line">    redisTemplate.opsForValue().</span><br><span class="line">      setIfAbsent(AuthServerConstant.SMS_CODE_CACHE_PREFIX + phone, </span><br><span class="line">      code + &quot;_&quot; + System.currentTimeMillis(), 10, TimeUnit.MINUTES);</span><br><span class="line">    thridPartFeignService.sendCode(phone, code);</span><br><span class="line">    return R.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="OAuth2-0"><a href="#OAuth2-0" class="headerlink" title="OAuth2.0"></a>OAuth2.0</h2><p><img src="https://raw.githubusercontent.com/boyiz/OSS/main/img/image-20220826180255958.png" alt="image-20220826180255958"></p>
<h3 id="微博社交登录"><a href="#微博社交登录" class="headerlink" title="微博社交登录"></a>微博社交登录</h3><ol>
<li><p>登录新浪微博开发平台进行登录：<a target="_blank" rel="noopener" href="https://open.weibo.com/%EF%BC%8C%E5%88%9B%E5%BB%BA%E4%B8%AA%E4%BA%BA%E4%BF%A1%E6%81%AF%EF%BC%8C%E5%88%9B%E5%BB%BA%E6%96%B0%E5%BA%94%E7%94%A8%E3%80%82">https://open.weibo.com/，创建个人信息，创建新应用。</a></p>
</li>
<li><p>API文档中的授权流程 ：</p>
<p>2.1、引导需要授权的用户到如下地址：</p>
<p><a target="_blank" rel="noopener" href="https://api.weibo.com/oauth2/authorize?client_id=YOUR_CLIENT_ID&amp;response_type=code&amp;redirect_uri=YOUR_REGISTERED_REDIRECT_URI">https://api.weibo.com/oauth2/authorize?client_id=YOUR_CLIENT_ID&amp;response_type=code&amp;redirect_uri=YOUR_REGISTERED_REDIRECT_URI</a><br>2.2、如果用户同意授权，页面跳转至 <code>YOUR_REGISTERED_REDIRECT_URI/?code=CODE</code><br>2.3、换取Access Token：</p>
<p><a target="_blank" rel="noopener" href="https://api.weibo.com/oauth2/access_token?client_id=YOUR_CLIENT_ID&amp;client_secret=YOUR_CLIENT_SECRET&amp;grant_type=authorization_code&amp;redirect_uri=YOUR_REGISTERED_REDIRECT_URI&amp;code=CODE">https://api.weibo.com/oauth2/access_token?client_id=YOUR_CLIENT_ID&amp;client_secret=YOUR_CLIENT_SECRET&amp;grant_type=authorization_code&amp;redirect_uri=YOUR_REGISTERED_REDIRECT_URI&amp;code=CODE</a><br>2.4、使用获得的Access Token调用API</p>
</li>
<li><p>测试得到access_token :</p>
<p>3.1、引导用户到达如下地址：client_id&#x3D;App Key，redirect_uri&#x3D;重定向地址</p>
<p><a target="_blank" rel="noopener" href="https://api.weibo.com/oauth2/authorize?client_id=AppKey&amp;response_type=code&amp;redirect_uri=%E9%87%8D%E5%AE%9A%E5%90%91%E5%9C%B0%E5%9D%80">https://api.weibo.com/oauth2/authorize?client_id=AppKey&amp;response_type=code&amp;redirect_uri=重定向地址</a><br>3.2、如果用户同意授权，页面跳转至 YOUR_REGISTERED_REDIRECT_URI&#x2F;?code&#x3D;CODE</p>
<p>​		用户同意授权后，就会获得一个code，拿到code我们就可以换取access_token</p>
<p>3.3、换取Access Token：</p>
</li>
</ol>
<p>​			<img src="https://raw.githubusercontent.com/boyiz/OSS/main/img/image-20220826181045286.png" alt="image-20220826181045286" style="zoom:50%;" /></p>
<ol start="4">
<li>使用获得的Access Token调用API</li>
</ol>
<p>​			<img src="https://raw.githubusercontent.com/boyiz/OSS/main/img/image-20220826181214770.png" alt="image-20220826181214770" style="zoom:50%;" /></p>
<p>整合</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;/weibo/success&quot;)</span><br><span class="line">public R weibo(@RequestParam(&quot;code&quot;) String code) throws Exception &#123;</span><br><span class="line">    //https://api.weibo.com/oauth2/authorize?client_id=YOUR_CLIENT_ID&amp;response_type=code&amp;redirect_uri=YOUR_REGISTERED_REDIRECT_URI</span><br><span class="line">    //https://api.weibo.com/oauth2/access_token?client_id=YOUR_CLIENT_ID&amp;client_secret=YOUR_CLIENT_SECRET&amp;grant_type=authorization_code&amp;redirect_uri=YOUR_REGISTERED_REDIRECT_URI&amp;code=CODE</span><br><span class="line">    Map&lt;String, String&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">    map.put(&quot;client_id&quot;, &quot;7******5&quot;);</span><br><span class="line">    map.put(&quot;client_secret&quot;, &quot;6c84***********b8a&quot;);</span><br><span class="line">    map.put(&quot;grant_type&quot;, &quot;authorization_code&quot;);</span><br><span class="line">    map.put(&quot;redirect_uri&quot;, &quot;http://gulimall.com/oauth2/weibo/success&quot;);</span><br><span class="line">    map.put(&quot;code&quot;, code);</span><br><span class="line">    //根据code换取access_token</span><br><span class="line">    HttpResponse response = HttpUtils.doPost(&quot;https://api.weibo.com&quot;, &quot;/oauth2/access_token&quot;, &quot;post&quot;, new HashMap&lt;&gt;(), map, new HashMap&lt;&gt;());</span><br><span class="line">    if (response.getStatusLine().getStatusCode() == 200) &#123;</span><br><span class="line">        //获取到access_token</span><br><span class="line">        String json = EntityUtils.toString(response.getEntity());</span><br><span class="line">        SocialUser socialUser = JSON.parseObject(json, SocialUser.class);</span><br><span class="line">        //判断用户是否已注册</span><br><span class="line">        //登录或注册，调用member远程方法</span><br><span class="line">        R r = memberFeignService.authLogin(socialUser);</span><br><span class="line">        return R.ok().put(&quot;data&quot;, r.get(&quot;data&quot;));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return R.error(BizCodeEnume.USER_AUTHLOGIN_EXCEPTION.getCode(),BizCodeEnume.USER_AUTHLOGIN_EXCEPTION.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="分布式session问题"><a href="#分布式session问题" class="headerlink" title="分布式session问题"></a>分布式session问题</h2><ul>
<li>在单体应用中，跨页面共享数据，我们可以使用session来存储，在浏览器打开到关闭期间，session 中存储的数据都能取出来，假如我们现在将登录的用户放在session中会有什么问题 ？</li>
</ul>
<img src="https://raw.githubusercontent.com/boyiz/OSS/main/img/image-20220826182522316.png" alt="image-20220826182522316" style="zoom:50%;" />

<p>存在问题：</p>
<ul>
<li>问题1：session不能跨不同域名进行共享，即使不是分布式情况下，只是使用不用服务部署不同域名：<ul>
<li>我们在首页<a target="_blank" rel="noopener" href="http://gulimall.com/%E4%B8%8B%E7%82%B9%E5%87%BB%E7%99%BB%E5%BD%95%EF%BC%8C%E8%B7%B3%E8%BD%AC%E5%88%B0%E7%99%BB%E5%BD%95%E9%A1%B5%EF%BC%9Ahttp://auth.gulimall.com/login.html">http://gulimall.com/下点击登录，跳转到登录页：http://auth.gulimall.com/login.html</a></li>
<li>在 <a target="_blank" rel="noopener" href="http://auth.gulimall.com/login.html">http://auth.gulimall.com/login.html</a> 下进行登录，域名为auth.gulimall.com（gulimall-auth服务），在这个域名下会保存服务器给浏览器响应的cookie（sessionID）</li>
<li>登录成功后，会跳转到<a target="_blank" rel="noopener" href="http://gulimall.com/">http://gulimall.com/</a> 下，域名为gulimall.com（gulimall-product服务），在这个域名下并没有服务器给浏览器响应的cookie（sessionID）</li>
</ul>
</li>
<li>问题2：session不同步问题<ul>
<li>即使是同域名的情况下，在分布式部署下，会员服务不可能只部署到一台服务器上去，可能多台服务器同时都有会员服务，假设浏览器第一次登录请求发给了1号服务器，那么1号服务器就把我们的用户保存了，由于我们是分布式集群环境，那么下一次请求可能会落到2号服务器，2号服务器并没有用户数据。</li>
</ul>
</li>
</ul>
<p>分布式Session情况下，Session不同步的四种解决方案 ：</p>
<ul>
<li>解决方案1：session复制</li>
</ul>
<p><img src="https://raw.githubusercontent.com/boyiz/OSS/main/img/image-20220826182953281.png" alt="image-20220826182953281"></p>
<ul>
<li>解决方案2：session存储在客户端</li>
</ul>
<p><img src="https://raw.githubusercontent.com/boyiz/OSS/main/img/image-20220826183053764.png" alt="image-20220826183053764"></p>
<ul>
<li>解决方案3 : hash一致性</li>
</ul>
<p><img src="https://raw.githubusercontent.com/boyiz/OSS/main/img/image-20220826183157840.png" alt="image-20220826183157840"></p>
<ul>
<li><p>解决方案4：统一存储 （项目中使用的方案）</p>
<p>我们将session数据统一存储在数据库DB或者redis中，解决sesison不同步的问题</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/boyiz/OSS/main/img/image-20220826183245102.png" alt="image-20220826183245102"></p>
<p> Sesison不能跨不同域名进行共享的解决方案：</p>
<ul>
<li>现在的问题是在auth.gulimal.com域名下会保存cookie，但是在gulimall.com中却没有，我们希望只要在子域名下的cookie，父域名也能感知到。</li>
<li>子域：gulimall.com，auth.gulimall.com，order.gulimall.com</li>
<li>父域：gulimall.com</li>
</ul>
<p><img src="https://raw.githubusercontent.com/boyiz/OSS/main/img/image-20220826183413170.png" alt="image-20220826183413170"></p>
<h2 id="使用JWT"><a href="#使用JWT" class="headerlink" title="使用JWT"></a>使用JWT</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">public final class JwtUtil &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 这个秘钥是防止JWT被篡改的关键，随便写什么都好，但决不能泄露</span><br><span class="line">     */</span><br><span class="line">    private final static String secretKey = &quot;gulimallJWT&quot;;</span><br><span class="line">    /**</span><br><span class="line">     * 过期时间设置，这个配置随业务需求而定</span><br><span class="line">     */</span><br><span class="line">    private final static Duration expiration = Duration.ofHours(5);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 生成JWT</span><br><span class="line">     *</span><br><span class="line">     * @param userName 用户名</span><br><span class="line">     * @return JWT</span><br><span class="line">     */</span><br><span class="line">    public static String generate(String userName) &#123;</span><br><span class="line">        // 过期时间</span><br><span class="line">        Date expiryDate = new Date(System.currentTimeMillis() + expiration.toMillis() * 10);</span><br><span class="line"></span><br><span class="line">        return Jwts.builder()</span><br><span class="line">                .setSubject(userName) // 将userName放进JWT</span><br><span class="line">                .setIssuedAt(new Date()) // 设置JWT签发时间</span><br><span class="line">                .setExpiration(expiryDate)  // 设置过期时间</span><br><span class="line">                .signWith(SignatureAlgorithm.HS512, secretKey) // 设置加密算法和秘钥</span><br><span class="line">                .compact();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 解析JWT</span><br><span class="line">     *</span><br><span class="line">     * @param token JWT字符串</span><br><span class="line">     * @return 解析成功返回Claims对象，解析失败返回null</span><br><span class="line">     */</span><br><span class="line">    public static Claims parse(String token) &#123;</span><br><span class="line">        // 如果是空字符串直接返回null</span><br><span class="line">        if (StringUtils.isEmpty(token)) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 这个Claims对象包含了许多属性，比如签发时间、过期时间以及存放的数据等</span><br><span class="line">        Claims claims = null;</span><br><span class="line">        // 解析失败了会抛出异常，所以我们要捕捉一下。token过期、token非法都会导致解析失败</span><br><span class="line">        try &#123;</span><br><span class="line">            claims = Jwts.parser()</span><br><span class="line">                    .setSigningKey(secretKey) // 设置秘钥</span><br><span class="line">                    .parseClaimsJws(token)</span><br><span class="line">                    .getBody();</span><br><span class="line">        &#125; catch (JwtException e) &#123;</span><br><span class="line">            // 这里应该用日志输出，为了演示方便就直接打印了</span><br><span class="line">            System.err.println(&quot;解析失败！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return claims;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>登录成功后将JWT封装在实体类中返回</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//返回jwt        memberEntity.setToken(JwtUtil.generate(memberEntity.getUsername()+&quot;_&quot;+memberEntity.getId()));              </span><br></pre></td></tr></table></figure>

<p>使用时</p>
<p>ThreadLocal的作用就是同一个线程共享数据，同一个线程：拦截器 -&gt; controller -&gt; service -&gt; dao</p>
<p>拿到JWT解析，获取用户ID，封装ThreadLocal</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class LoginUserInterceptor extends HandlerInterceptorAdapter &#123;</span><br><span class="line">    public static ThreadLocal&lt;MemberResponseVo&gt; loginUser = new ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;</span><br><span class="line">        String uri = request.getRequestURI();</span><br><span class="line">        AntPathMatcher antPathMatcher = new AntPathMatcher();</span><br><span class="line">        boolean match = antPathMatcher.match(&quot;/order/order/status/**&quot;, uri);</span><br><span class="line">        boolean match1 = antPathMatcher.match(&quot;/payed/**&quot;, uri);</span><br><span class="line">        if (match || match1) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        // 从请求头中获取token字符串</span><br><span class="line">        String jwt = request.getHeader(&quot;Authorization&quot;);</span><br><span class="line">        // 解析失败就提示用户登录</span><br><span class="line">        Claims claims = JwtUtil.parse(jwt);</span><br><span class="line">        if (claims != null) &#123;</span><br><span class="line">            MemberResponseVo memberResponseVo = new MemberResponseVo();</span><br><span class="line">            memberResponseVo.setId(</span><br><span class="line">                    Long.parseLong(</span><br><span class="line">                            claims.get(&quot;sub&quot;).toString().split(&quot;_&quot;)[1]));</span><br><span class="line">            loginUser.set(memberResponseVo);</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            throw new RRException(&quot;当前用户未登录&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="消息队列-RabbitMQ"><a href="#消息队列-RabbitMQ" class="headerlink" title="消息队列 RabbitMQ"></a>消息队列 RabbitMQ</h2><h3 id="RabbitMQ简介"><a href="#RabbitMQ简介" class="headerlink" title="RabbitMQ简介"></a>RabbitMQ简介</h3><ul>
<li>RabbitMQ是一个由erlang开发的AMQP(Advanved Message Queue Protocol)的开源实现。</li>
</ul>
<p>Message消息：消息是不具名的，它由消息头和消息体组成。消息体是不透明的，而消息头则由一系列的可选属性组成，<br>这些属性包括routing-key（路由键）、priority（相对于其他消息的优先权）、delivery-mode（指出该消息可能需要持久性存储）等。</p>
<p>Publisher消息的生产者：也是一个向交换器发布消息的客户端应用程序。</p>
<p><strong>Exchange交换器</strong>：用来接收生产者发送的消息并将这些消息路由给服务器中的队列。<br>Exchange有4种类型：direct(默认)，fanout，topic，和headers，不同类型的Exchange转发消息的策略有所区别。</p>
<p><strong>Queue消息队列</strong>：用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。一个消息可投入一个或多个队列。消息一直在队列里面，等待消费者连接到这个队列将其取走。</p>
<p><strong>Binding绑定</strong>：用于消息队列和交换器之间的关联。一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。Exchange 和Queue的绑定可以是多对多的关系。</p>
<p>Connection网络连接：比如一个TCP连接。</p>
<p><strong>Channel信道</strong>：多路复用连接中的一条独立的双向数据流通道。信道是建立在真实的TCP连接内的虚拟连接，AMQP 命令都是通过信道发出去的，不管是发布消息、订阅队列还是接收消息，这些动作都是通过信道完成。因为对于操作系统来说建立和销毁 TCP 都是非常昂贵的开销，所以引入了信道的概念，以复用一条 TCP 连接。</p>
<p>Consumer消息的消费者：表示一个从消息队列中取得消息的客户端应用程序。</p>
<p>Virtual Host虚拟主机：表示一批交换器、消息队列和相关对象。虚拟主机是共享相同的身份认证和加密环境的独立服务器域。每个 vhost 本质上就是一个 mini 版的 RabbitMQ 服务器，拥有自己的队列、交换器、绑定和权限机制。vhost 是 AMQP 概念的基础，必须在连接时指定，RabbitMQ 默认的 vhost 是 &#x2F; 。</p>
<p>Broker：表示消息队列服务器实体</p>
<p><img src="https://raw.githubusercontent.com/boyiz/OSS/main/img/image-20220826185008691.png" alt="image-20220826185008691"></p>
<h4 id="Exchange类型"><a href="#Exchange类型" class="headerlink" title="Exchange类型"></a>Exchange类型</h4><p>AMQP 中消息的路由过程和 Java 开发者熟悉的 JMS 存在一些差别，AMQP 中增加了 Exchange 和Binding 的角色。生产者把消息发布到 Exchange 上，消息最终到达队列并被消费者接收，而 Binding 决定交换器的消息应该发送到那个队列。</p>
<img src="https://raw.githubusercontent.com/boyiz/OSS/main/img/image-20220826185129809.png" alt="image-20220826185129809" style="zoom:50%;" />

<p>Exchange分发消息时根据类型的不同分发策略有区别，目前共四种类型：direct、fanout、topic、headers</p>
<ul>
<li><p>direct 直接路由：</p>
<ul>
<li><p>消息中的路由键（routing key）如果和Binding 中的 binding key 一致， 交换器就将消息发到对应的队列中。路由键与队列名完全匹配，如果一个队列绑定到交换机要求路由键为“dog”，则只转发 routing key 标记为“dog”的消息，不会转发“dog.puppy”，也不会转发“dog.guard”等等。</p>
</li>
<li><p>它是完全匹配、单播的模式。</p>
<img src="https://raw.githubusercontent.com/boyiz/OSS/main/img/image-20220826185605897.png" alt="image-20220826185605897" style="zoom:75%;" /></li>
</ul>
</li>
<li><p>fanout 广播：</p>
<ul>
<li><p>每个发到 fanout 类型交换器的消息都会分到所有绑定的队列上去。fanout 交换器不处理路由键，只是简单的将队列绑定到交换器上，每个发送到交换器的消息都会被转发到与该交换器绑定的所有队列上。很像子网广播，每台子网内的主机都获得了一份复制的消息。</p>
</li>
<li><p>fanout 类型转发消息是最快的。</p>
<img src="https://raw.githubusercontent.com/boyiz/OSS/main/img/image-20220826185631099.png" alt="image-20220826185631099" style="zoom:75%;" /></li>
</ul>
</li>
<li><p>topic 发布订阅：</p>
<ul>
<li><p>topic 交换器通过模式匹配分配消息的路由键属性，将路由键和某个模式进行匹配，此时队列需要绑定到一个模式上。它将路由键和绑定键的字符串切分成单词，这些单词之间用点隔开。它同样也会识别两个通配符：符号<code>#</code>和符号<code>*</code>。</p>
</li>
<li><p><code>#</code>匹配 0个或多个单词，<code>*</code>匹配一个单词。</p>
<p><img src="https://raw.githubusercontent.com/boyiz/OSS/main/img/image-20220826185652253.png" alt="image-20220826185652253"></p>
</li>
</ul>
</li>
</ul>
<h4 id="Spring-Boot整合RabbitMQ"><a href="#Spring-Boot整合RabbitMQ" class="headerlink" title="Spring Boot整合RabbitMQ"></a>Spring Boot整合RabbitMQ</h4><p>1）引入 spring-boot-starter-amqp 依赖</p>
<p>2）在application.yml中配置属性</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">spring.rabbitmq.host=192.168.xx.xx</span></span><br><span class="line"><span class="string">spring.rabbitmq.port=5672</span></span><br><span class="line"><span class="string">spring.rabbitmq.virtual-host=/</span></span><br></pre></td></tr></table></figure>

<p>3）主启动类上开启RabbitMQ的相关功能，使用 <code>@EnableRabbit</code> 注解</p>
<p>4）测试创建交换机，队列，将队列绑定交换机</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GulimallOrderApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    AmqpAdmin amqpAdmin;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//DirectExchange(String name, boolean durable, boolean autoDelete, Map&lt;String, Object&gt; arguments)</span></span><br><span class="line">        <span class="comment">// 创建交换机</span></span><br><span class="line">        <span class="type">DirectExchange</span> <span class="variable">directExchange</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(<span class="string">&quot;hello-java-exchange&quot;</span>,<span class="literal">true</span>,<span class="literal">false</span>);</span><br><span class="line">        amqpAdmin.declareExchange(directExchange);</span><br><span class="line">        log.info(<span class="string">&quot;Exchange[&#123;&#125;]创建成功&quot;</span>, <span class="string">&quot;hello-java-exchange&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//public Queue(String name, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments)</span></span><br><span class="line">        <span class="type">Queue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;hello-java-queue&quot;</span>,<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">false</span>);</span><br><span class="line">        amqpAdmin.declareQueue(queue);</span><br><span class="line">        log.info(<span class="string">&quot;Queue[&#123;&#125;]创建成功&quot;</span>, <span class="string">&quot;hello-java-queue&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将交换机和队列绑定</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createBinding</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// ( String destination【目的地】,</span></span><br><span class="line">        <span class="comment">//   DestinationType destinationType【目的地类型】,</span></span><br><span class="line">        <span class="comment">//   String exchange【交换机】,</span></span><br><span class="line">        <span class="comment">//   String routingKey【路由键】,</span></span><br><span class="line">        <span class="comment">//   Map&lt;String, Object&gt; arguments【自定义参数】)</span></span><br><span class="line">        <span class="comment">//将exchange指定的交换机和destination目的地进行绑定，使用routingKey作为指定的路由键</span></span><br><span class="line">        <span class="type">Binding</span> <span class="variable">binding</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Binding</span>(<span class="string">&quot;hello-java-queue&quot;</span>,</span><br><span class="line">                Binding.DestinationType.QUEUE, <span class="string">&quot;hello-java-exchange&quot;</span>,</span><br><span class="line">                <span class="string">&quot;hello.java&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">        amqpAdmin.declareBinding(binding);</span><br><span class="line">        log.info(<span class="string">&quot;Binding[&#123;&#125;]创建成功&quot;</span>, <span class="string">&quot;hello-java-binding&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5）测试发送消息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符串消息</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">   rabbitTemplate.convertAndSend(<span class="string">&quot;hello.java.exchange&quot;</span>,<span class="string">&quot;hello.java&quot;</span>, msg);</span><br><span class="line">   log.info(<span class="string">&quot;消息发送完成&#123;&#125;&quot;</span>,msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对象消息：【对象必须实现 Serializable】</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试发送 实体类 消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> num</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/sendMq&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sendMq</span><span class="params">(<span class="meta">@RequestParam(value = &quot;num&quot;,defaultValue = &quot;10&quot;)</span> Integer num)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//如果发送的消息是个对象，我们会使用序列化机制，将对象写出去，对象必须实现Serializable接口</span></span><br><span class="line">                <span class="type">OrderReturnReasonEntity</span> <span class="variable">reasonEntity</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderReturnReasonEntity</span>();</span><br><span class="line">                reasonEntity.setCreateTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">                reasonEntity.setId(<span class="number">1L</span>);</span><br><span class="line">                reasonEntity.setName(<span class="string">&quot;退货原因&quot;</span>+i);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//发送的对象类型的消息是一个json，需要重新定义消息转换器Jackson2JsonMessageConverter</span></span><br><span class="line">                rabbitTemplate.convertAndSend(<span class="string">&quot;hello.java.exchange&quot;</span>,<span class="string">&quot;hello.java&quot;</span>, reasonEntity);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">OrderEntity</span> <span class="variable">orderEntity</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderEntity</span>();</span><br><span class="line">                orderEntity.setOrderSn(UUID.randomUUID().toString());</span><br><span class="line">                rabbitTemplate.convertAndSend(<span class="string">&quot;hello.java.exchange&quot;</span>,<span class="string">&quot;hello.java&quot;</span>, orderEntity);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：如果发送对象，使用JSON序列化机制，进行消息转换，否则发送出去的就是字节数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRabbitConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MessageConverter <span class="title function_">messageConverter</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonMessageConverter</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6）监听队列中的消息 ：【进行消费】</p>
<p>监听消息：使用@RabbitListener；主启动类必须有@EnableRabbit<br>@RabbitListener：类+方法上（监听哪些队列即可）<br>@RabbitHandler：标在方法上（重载区分不同的消息）</p>
<p>Queue：可以很多人都来监听。只要收到消息，队列删除消息，而且只能有一个收到此消息</p>
<p>场景：<br>① 订单服务启动多个；同一个消息，只能有一个客户端收到.<br>② 只有一个消息完全处理完，方法运行结束，我们就可以接收到下一个消息.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &#123;&quot;hello-java-queue&quot;&#125;)</span></span><br><span class="line"><span class="meta">@Service(&quot;orderItemService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderItemServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;OrderItemDao, OrderItemEntity&gt; <span class="keyword">implements</span> <span class="title class_">OrderItemService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//@RabbitListener(queues = &#123;&quot;hello-java-queue&quot;&#125;)</span></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">recieveMessage</span><span class="params">(Message message, OrderReturnReasonEntity content,</span></span><br><span class="line"><span class="params">                               Channel channel)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;接收到消息...&quot;</span> + message);</span><br><span class="line">        System.out.println(<span class="string">&quot;内容：&quot;</span>+content);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">recieveMessage2</span><span class="params">(OrderEntity content)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;内容...&quot;</span> +content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RabbitMQ消息确认机制"><a href="#RabbitMQ消息确认机制" class="headerlink" title="RabbitMQ消息确认机制"></a>RabbitMQ消息确认机制</h3><p>使用消息传递代理（例如RabbitMQ）的系统是分布式的。由于不能保证发送消息可以到达对等方或被其成功处理，因此发布者和使用者都需要一种机制来进行传递和处理确认。</p>
<p>保证消息不丢失，可靠抵达，可以使用事务消息，性能下降250倍，为此引入确认机制<br>• publisher —— confirmCallback   确认模式<br>• publisher —— returnCallback 未投递到 queue   退回模式<br>• consumer   ack机制</p>
 <img src="https://raw.githubusercontent.com/boyiz/OSS/main/img/image-20220911092209177.png" alt="image-20220911092209177" style="zoom:67%;" />

<h4 id="可靠抵达-ConfirmCallback"><a href="#可靠抵达-ConfirmCallback" class="headerlink" title="可靠抵达 - ConfirmCallback"></a>可靠抵达 - ConfirmCallback</h4><p>只要消息抵达Broker就ack&#x3D;true</p>
<p>• 设置 PublisherConfirms(true) 选项，开启confirmcallback 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">开启发送者确认模式</span><br><span class="line">spring.rabbitmq.publisher-confirms=true</span><br></pre></td></tr></table></figure>
<p>• 消息只要被 broker 接收到就会执行 confirmCallback，如果是 cluster 模式，需要所有broker 接收到才会调用 confirmCallback。</p>
<p>• CorrelationData：用来表示当前消息唯一性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRabbitConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定制rabbitMq</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// Constructor(构造方法) -&gt; @Autowired(依赖注入) -&gt; @PostConstruct(注释的方法)</span></span><br><span class="line">    <span class="meta">@PostConstruct</span> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initRabbitTemplate</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//设置确认回调 : 只要消息抵达Broker就ack=true</span></span><br><span class="line">        rabbitTemplate.setConfirmCallback(<span class="keyword">new</span> <span class="title class_">RabbitTemplate</span>.ConfirmCallback() &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> correlationData 当前消息的唯一关联数据</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> ack 消息是否成功收到</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> cause 失败的原因</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">confirm</span><span class="params">(CorrelationData correlationData, <span class="type">boolean</span> ack, String cause)</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;correlationData--》&quot;</span>+correlationData +<span class="string">&quot;ack--》&quot;</span>+ack + <span class="string">&quot;causer--》&quot;</span>+cause);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="可靠抵达-ReturnCallback"><a href="#可靠抵达-ReturnCallback" class="headerlink" title="可靠抵达 - ReturnCallback"></a>可靠抵达 - ReturnCallback</h4><p>• confrim 模式只能保证消息到达 broker，不能保证消息准确投递到目标 queue 里。在有些业务场景下，我们需要保证消息一定要投递到目标 queue 里，此时就需要用到 return 退回模式。</p>
<p>• 这样如果未能投递到目标 queue 里将调用 returnCallback ，可以记录下详细到投递数据，定期的巡检或者自动纠错都需要这些数据。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 开启发送端消息抵达队列的确认</span><br><span class="line">spring.rabbitmq.publisher-returns=true</span><br><span class="line"># 只要抵达队列，以异步发送优先回调我们这个returnconfirm</span><br><span class="line">spring.rabbitmq.template.mandatory=true</span><br></pre></td></tr></table></figure>

<p>• 被 broker 接收到只能表示 message 已经到达服务器，并不能保证消息一定会被投递到目标 queue 里。所以需要用到接下来的returnCallback</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRabbitConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定制rabbitMq</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostConstruct</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initRabbitTemplate</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//1、设置确认回调 : 只要消息抵达Broker就ack=true</span></span><br><span class="line">        rabbitTemplate.setConfirmCallback(<span class="keyword">new</span> <span class="title class_">RabbitTemplate</span>.ConfirmCallback() &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> correlationData 当前消息的唯一关联数据</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> ack 消息是否成功收到</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> cause 失败的原因</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">confirm</span><span class="params">(CorrelationData correlationData, <span class="type">boolean</span> ack, String cause)</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;correlationData--》&quot;</span></span><br><span class="line">                                   +correlationData +<span class="string">&quot;ack--》&quot;</span>+ack + <span class="string">&quot;causer--》&quot;</span>+cause);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、设置消息抵达队列的确认回调: 只有失败时才会调用这个消息</span></span><br><span class="line">        rabbitTemplate.setReturnCallback(<span class="keyword">new</span> <span class="title class_">RabbitTemplate</span>.ReturnCallback() &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 只要消息没有投递给指定的队列，就触发这个失败回调</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> message   投递失败的消息详细信息</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> replyCode 回复的状态码</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> replyText 回复的文本内容</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> exchange  当时这个消息发给哪个交换机</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> routingKey 当时这个消息用哪个路由键</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">returnedMessage</span><span class="params">(Message message, <span class="type">int</span> replyCode, String replyText, String exchange, String routingKey)</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Fail Message[&quot;</span>+message+<span class="string">&quot;]--&gt;replyCode[&quot;</span>+replyCode+<span class="string">&quot;]--&gt;replyText[&quot;</span>+replyText+<span class="string">&quot;]--&gt;exchange[&quot;</span>+exchange+<span class="string">&quot;]--&gt;routingKey[&quot;</span>+routingKey+<span class="string">&quot;]&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="可靠抵达-Ack消息确认机制"><a href="#可靠抵达-Ack消息确认机制" class="headerlink" title="可靠抵达 - Ack消息确认机制"></a>可靠抵达 - Ack消息确认机制</h4><p>消费者获取到消息，成功处理，可以回复Ack给Broker<br>    • basic.ack 用于肯定确认；broker将移除此消息<br>    • basic.nack 用于否定确认；可以指定broker是否丢弃此消息，可以批量<br>    • basic.reject 用于否定确认；可以指定broker是否丢弃此消息，但不能批量</p>
<p>默认自动ack，消息被消费者收到，就会从broker的queue中移除；</p>
<p>queue无消费者，消息依然会被存储，直到消费者消费；</p>
<p>消费者收到消息，默认会自动ack，</p>
<p>如果无法确定此消息是否被处理完成，或者成功处理，我们可以开启<strong>手动ack模式</strong></p>
<p><strong><em>消息确认的类型</em>：</strong></p>
<ul>
<li><strong>channel.basicAck(deliveryTag, multiple)</strong><ul>
<li>consumer处理成功后，通知broker删除队列中的消息，如果设置multiple&#x3D;true，表示支持批量确认机制以减少网络流量。<br>例如：有值为5,6,7,8 deliveryTag的投递<br>如果此时channel.basicAck(8,  <em>true</em>)——则表示前面未确认的5,6,7投递也一起确认处理完毕。<br>如果此时channel.basicAck(8,  <em>false</em>)——则仅表示deliveryTag&#x3D;8的消息已经成功处理。</li>
</ul>
</li>
<li><strong>channel.basicNack(deliveryTag, multiple, requeue)</strong><ul>
<li>consumer处理失败后，</li>
<li>例如：有值为5,6,7,8 deliveryTag的投递。<br>如果channel.basicNack(8, true, true)——表示deliveryTag&#x3D;8之前未确认的消息都处理失败且将这些消息重新放回队列中。<br>如果channel.basicNack(8, true, false)——表示deliveryTag&#x3D;8之前未确认的消息都处理失败且将这些消息丢弃。<br>如果channel.basicNack(8, false, true)——表示deliveryTag&#x3D;8的消息处理失败且将该消息重新放回队列。<br>如果channel.basicNack(8, false, false)——表示deliveryTag&#x3D;8的消息处理失败且将该消息直接丢弃。</li>
</ul>
</li>
<li><strong>channel.basicReject(deliveryTag, requeue)</strong><ul>
<li>相比channel.basicNack，除了没有multiple <em>批量确认机制</em> 之外，其他语义完全一样。<br>如果channel.basicReject(8, true)——表示deliveryTag&#x3D;8的消息处理失败且将该消息重新放回队列。<br>如果channel.basicReject(8, false)——表示deliveryTag&#x3D;8的消息处理失败且将该消息直接丢弃。</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 设置为手动ack方式</span><br><span class="line">spring.rabbitmq.listener.simple.acknowledge-mode=manual</span><br></pre></td></tr></table></figure>

<p>此时监听队列中的消息，并设置手动确认：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &#123;&quot;hello-java-queue&quot;&#125;)</span></span><br><span class="line"><span class="meta">@Service(&quot;orderItemService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderItemServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;OrderItemDao, OrderItemEntity&gt; <span class="keyword">implements</span> <span class="title class_">OrderItemService</span> &#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 参数可以写的以下类型</span></span><br><span class="line"><span class="comment">	 * 1. Message message：原生消息详细信息，头+体</span></span><br><span class="line"><span class="comment">	 * 2. T&lt;发送消息的类型&gt; OrderReturnReasonEntity content</span></span><br><span class="line"><span class="comment">	 * 3. Channel channel：当前传输数据的通道</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">recieveMessage</span><span class="params">(Message message, OrderReturnReasonEntity content,</span></span><br><span class="line"><span class="params">                               Channel channel)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//消息体信息</span></span><br><span class="line">        <span class="type">byte</span>[] body = message.getBody();</span><br><span class="line">        <span class="comment">//消息头属性信息</span></span><br><span class="line">        <span class="type">MessageProperties</span> <span class="variable">messageProperties</span> <span class="operator">=</span> message.getMessageProperties();</span><br><span class="line"><span class="comment">//        Thread.sleep(3000);</span></span><br><span class="line">        System.out.println(<span class="string">&quot;消息处理完==&gt;&quot;</span> + content.getName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//deliveryTag 是 channel内按顺序自增的</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">deliveryTag</span> <span class="operator">=</span> message.getMessageProperties().getDeliveryTag();</span><br><span class="line">        System.out.println(<span class="string">&quot;deliveryTag ==&gt; &quot;</span> + deliveryTag);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//签收获取，非批量模式</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (deliveryTag%<span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                channel.basicAck(deliveryTag,<span class="literal">false</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;签收了货物...&quot;</span> + deliveryTag);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// requeue = false 丢弃， = true 发回服务器，服务器重新入队</span></span><br><span class="line">                <span class="comment">//long deliveryTag, boolean multiple, boolean requeue</span></span><br><span class="line">                channel.basicNack(deliveryTag,<span class="literal">false</span>,<span class="literal">true</span>);</span><br><span class="line">                <span class="comment">//long deliveryTag, boolean requeue</span></span><br><span class="line"><span class="comment">//                channel.basicReject();</span></span><br><span class="line">                System.out.println(<span class="string">&quot;没有签收了货物...&quot;</span> + deliveryTag);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">recieveMessage2</span><span class="params">(OrderEntity content)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;接收消息...&quot;</span> +content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="消息的TTL-Time-To-Live"><a href="#消息的TTL-Time-To-Live" class="headerlink" title="消息的TTL(Time To Live)"></a>消息的TTL(Time To Live)</h3><ul>
<li>消息的TTL就是消息的存活时间。</li>
<li>RabbitMQ可以对队列和消息分别设置TTL。<ul>
<li>对队列设置就是队列没有消费者连着的保留时间，也可以对每一个单独的消息做单独的设置。超过了这个时间，我们认为这个消息就死了，称之为 <em><strong>死信</strong></em>。</li>
<li>如果队列设置了，消息也设置了，那么会取小的值。所以一个消息如果被路由到不同的队 列中，这个消息死亡的时间有可能不一样(不同的队列设置)。这里单讲单个消息的 TTL，因为它才是实现延迟任务的关键。可以通过设置消息的expiration字段或者x- message-ttl属性来设置时间，两者是一样的效果。</li>
</ul>
</li>
</ul>
<h3 id="Dead-Letter-Exchanges-DLX-死信路由"><a href="#Dead-Letter-Exchanges-DLX-死信路由" class="headerlink" title="Dead Letter Exchanges (DLX) 死信路由"></a>Dead Letter Exchanges (DLX) 死信路由</h3><ul>
<li>一个消息在满足如下条件下，会进死信路由，记住这里是 <code>路由</code> 而不是 <code>队列</code> ， 一个路由可以对应很多队列。(什么是死信)<ul>
<li>一个消息被Consumer拒收了，并且reject方法的参数里requeue是false。也就是说不 会被再次放在队列里，被其他消费者使用。(<em>basic.reject&#x2F; basic.nack</em>)<em>requeue&#x3D;false</em></li>
<li>上面的消息的TTL到了，消息过期了。</li>
<li>队列的长度限制满了。排在前面的消息会被丢弃或者扔到死信路由上</li>
</ul>
</li>
<li>Dead Letter Exchange其实就是一种普通的exchange，和创建其他 exchange没有两样。只是在某一个设置Dead Letter Exchange的队列中有消息过期了，会自动触发消息的转发，发送到Dead Letter Exchange中去。</li>
<li>我们既可以控制消息在一段时间后变成死信，又可以控制变成死信的消息被路由到某一个指定的交换机，结合二者，其实就可以实现一个延时队列</li>
<li>手动ack&amp;异常消息统一放在一个队列处理建议的两种方式<ul>
<li>catch异常后，<strong>手动发送到指定队列</strong>，然后使用channel给rabbitmq确认消息已消费 </li>
<li>给Queue绑定死信队列，使用nack(requque为false)确认消息消费失败</li>
</ul>
</li>
</ul>
<h3 id="延时队列实现"><a href="#延时队列实现" class="headerlink" title="延时队列实现"></a>延时队列实现</h3><p>场景：比如未付款订单，超过一定时间后，系统自动取消订单并释放占有物品。<br>常用解决方案：spring的 schedule 定时任务轮询数据库<br>缺点：消耗系统内存、增加了数据库的压力、存在较大的时间误差<br>解决：rabbitmq的消息TTL和死信Exchange结合</p>
<h4 id="设置队列过期时间"><a href="#设置队列过期时间" class="headerlink" title="设置队列过期时间"></a>设置队列过期时间</h4><p>消息首先交给交换机，交换机按照路由键发给指定的队列，这个队列设置了过期时间，以及死信路由键，由于没有消费者这监听这个队列，当消息死了扔给指定的队列。</p>
<p><img src="https://raw.githubusercontent.com/boyiz/OSS/main/img/image-20220911094605547.png" alt="image-20220911094605547"></p>
<h4 id="设置消息过期时间"><a href="#设置消息过期时间" class="headerlink" title="设置消息过期时间"></a>设置消息过期时间</h4><p>发送消息的时候，单独为消息设置过期时间，消息经过交换机发给延时队列，由于没有消费者这监听这个队列，消息过期之后就会发给死信交换机，通过交换机发给指定的队列。</p>
<p><img src="https://raw.githubusercontent.com/boyiz/OSS/main/img/image-20220911094647877.png" alt="image-20220911094647877"></p>
<p><strong>模拟关单简单方式</strong> ：</p>
<p>创建两个交换机 ：<code>user.order.delay.exchange</code> 和 <code>user.order.exchange</code> ，这两个交换机各绑定了一个队列，其中死信队列：<code>user.order.delay.queue</code> 是没有消费者监听的，<code>user.order.queue</code>是有消费者监听的，当订单服务创建一个订单后会将消息发送给<code>user.order.delay.exchange</code>交换机，这个交换机经过指定的路由键order_delay发给<code>user.order.delay.queue</code>队列，由于队列的过期时间<code>x-message-ttl=60000</code>，即为1分钟，当1分钟之后，队列就会过期变为死信，交给<code>x-dead-letter-exchange: user.order.exchange</code> ，通过路由键<code>x-dead-letter-routing-key: order</code> 发给指定的队列<code>user.order.queue</code>。</p>
<p><img src="https://raw.githubusercontent.com/boyiz/OSS/main/img/image-20220911094844608.png" alt="image-20220911094844608"></p>
<p><strong>模拟关单升级方式</strong> </p>
<p>消息创建成功后先按照 <code>order.create.order</code> 找到对应的交换机 <code>orer-event-exchange</code>，在按照 <code>order.create.order</code> 找到对应的队列 <code>order.delay.queue</code> ，这个队列是一个延时队列，设置了三个参数：<code>x-dead-letter-exchange: order-event-exchange</code> ，当队列中的消息经过<code>x-message-ttl: 60000</code> 时间后变成死信，然后通过<code>x-dead-letter-routing-key: order.release.order</code>找到这个队列<code>order.release.order</code>，将死信交给它 。</p>
<p><img src="https://raw.githubusercontent.com/boyiz/OSS/main/img/image-20220911094905412.png" alt="image-20220911094905412"></p>
<p>创建交换机，队列，以及绑定关系：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyMQConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 死信队列</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">orderDelayOrderQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * x-dead-letter-exchange: order-event-exchange</span></span><br><span class="line"><span class="comment">         * x-dead-letter-routing-key: order.release.order</span></span><br><span class="line"><span class="comment">         * x-message-ttl: 60000</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, <span class="string">&quot;order-event-exchange&quot;</span>);</span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;order.release.order&quot;</span>);</span><br><span class="line">        arguments.put(<span class="string">&quot;x-message-ttl&quot;</span>, <span class="number">120000</span>);<span class="comment">//两分钟</span></span><br><span class="line">        <span class="comment">//String name, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments</span></span><br><span class="line">        <span class="type">Queue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;order.delay.queue&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, arguments);</span><br><span class="line">        <span class="keyword">return</span> queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 队列</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">orderReleaseOrderQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Queue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;order.release.order.queue&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">return</span> queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换机</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Exchange <span class="title function_">orderEventExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//String name, boolean durable, boolean autoDelete, Map&lt;String, Object&gt; arguments</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TopicExchange</span>(<span class="string">&quot;order-event-exchange&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定关系</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">orderCreateOrderBinding</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//String destination, DestinationType destinationType, String exchange, String routingKey,Map&lt;String, Object&gt; arguments</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Binding</span>(<span class="string">&quot;order.delay.queue&quot;</span>,</span><br><span class="line">                Binding.DestinationType.QUEUE,</span><br><span class="line">                <span class="string">&quot;order-event-exchange&quot;</span>,</span><br><span class="line">                <span class="string">&quot;order.create.order&quot;</span>,</span><br><span class="line">                <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定关系</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">orderReleaseOrderBinding</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Binding</span>(<span class="string">&quot;order.release.order.queue&quot;</span>,</span><br><span class="line">                Binding.DestinationType.QUEUE,</span><br><span class="line">                <span class="string">&quot;order-event-exchange&quot;</span>,</span><br><span class="line">                <span class="string">&quot;order.release.order&quot;</span>,</span><br><span class="line">                <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 订单释放直接和库存释放进行绑定</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">orderReleaseOtherBingding</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Binding</span>(<span class="string">&quot;stock.release.stock.queue&quot;</span>,</span><br><span class="line">                Binding.DestinationType.QUEUE,</span><br><span class="line">                <span class="string">&quot;order-event-exchange&quot;</span>,</span><br><span class="line">                <span class="string">&quot;order.release.other.#&quot;</span>,</span><br><span class="line">                <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建订单并给消息队列发送消息测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/test/createOrder&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">createOrderTest</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//订单下单成功</span></span><br><span class="line">        <span class="type">OrderEntity</span> <span class="variable">entity</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderEntity</span>();</span><br><span class="line">        entity.setOrderSn(UUID.randomUUID().toString());</span><br><span class="line">        entity.setModifyTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//给MQ发送消息。</span></span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;order-event-exchange&quot;</span>,<span class="string">&quot;order.create.order&quot;</span>,entity);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="如何保证消息可靠性"><a href="#如何保证消息可靠性" class="headerlink" title="如何保证消息可靠性"></a>如何保证消息可靠性</h3><h4 id="消息丢失"><a href="#消息丢失" class="headerlink" title="消息丢失"></a>消息丢失</h4><ul>
<li>消息发送出去，由于网络问题没有抵达服务器</li>
</ul>
<p>• 做好容错方法(try-catch)，发送消息可能会网络失败，失败后要有重试机制，可记录到数据库，采用定期扫描重发的方式</p>
<p>• 做好日志记录，每个消息状态是否都被服务器收到都应该记录</p>
<p>• 做好定期重发，如果消息没有发送成功，定期去数据库扫描未成功的消息进行重发</p>
<p>-<br>  消息抵达Broker，Broker要将消息写入磁盘(持久化)才算成功；但此时Broker尚未持久化完成，发生宕机。</p>
<p>• publisher也必须加入确认回调机制，确认成功的消息，修改数据库消息状态。</p>
<ul>
<li>自动ACK的状态下，消费者收到消息，但没来得及消息然后宕机</li>
</ul>
<p>• 一定开启手动ACK，消费成功才移除，失败或者没来得及处理就noAck并重新入队</p>
<h4 id="消息重复"><a href="#消息重复" class="headerlink" title="消息重复"></a>消息重复</h4><ul>
<li>消息消费成功，事务已经提交，ack时，机器宕机。导致没有ack成功，Broker的消息 重新由unack变为ready，并发送给其他消费者</li>
<li>消息消费失败，由于重试机制，自动又将消息发送出去</li>
<li>成功消费，ack时宕机，消息由unack变为ready，Broker又重新发送</li>
</ul>
<p>• 消费者的业务消费接口应该设计为<strong>幂等性</strong>的。比如扣库存有工作单的状态标志</p>
<p>• 使用<strong>防重表</strong>(redis&#x2F;mysql)，发送消息每一个都有业务的唯一标识，处理过就不用处理</p>
<p>• rabbitMQ的每一个消息都有redelivered字段，可以获取<strong>是否是被重新投递过来的</strong>，而不是第一次投递过来的</p>
<h4 id="消息积压"><a href="#消息积压" class="headerlink" title="消息积压"></a>消息积压</h4><ul>
<li>消费者宕机积压</li>
<li>消费者消费能力不足积压</li>
<li>发送者发送流量太大</li>
</ul>
<p>• 上线更多的消费者，进行正常消费</p>
<p>• 上线专门的队列消费服务，将消息先批量取出来，记录数据库，离线慢慢处理</p>
<h2 id="商城业务-订单业务"><a href="#商城业务-订单业务" class="headerlink" title="商城业务 - 订单业务"></a>商城业务 - 订单业务</h2><p><img src="https://raw.githubusercontent.com/boyiz/OSS/main/img/%E7%94%B5%E5%95%86%E8%AE%A2%E5%8D%95%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="电商订单流程图"></p>
<p>订单的创建与支付：</p>
<p>(1) 、 订单创建前需要预览订单， 选择收货信息等<br>(2) 、 订单创建需要锁定库存， 库存有才可创建， 否则不能创建<br>(3) 、 订单创建后超时未支付需要解锁库存<br>(4) 、 支付成功后， 需要进行拆单， 根据商品打包方式， 所在仓库， 物流等进行拆单<br>(5) 、 支付的每笔流水都需要记录，以待查账<br>(6) 、 订单创建， 支付成功等状态都需要给 MQ 发送消息， 方便其他系统感知订阅</p>
<p>订单确认流程</p>
<p><img src="https://raw.githubusercontent.com/boyiz/OSS/main/img/%E8%AE%A2%E5%8D%95%E7%A1%AE%E8%AE%A4%E9%A1%B5%E6%B5%81%E7%A8%8B.png" alt="订单确认页流程"></p>
<h3 id="接口幂等性"><a href="#接口幂等性" class="headerlink" title="接口幂等性"></a>接口幂等性</h3><p>接口幂等性就是用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生了副作用；比如说支付场景， 用户购买了商品支付扣款成功， 但是返回结果的时候网络异常， 此时钱已经扣了， 用户再次点击按钮， 此时会进行第二次扣款， 返回结果成功， 用户查询余额返发现多扣钱了， 流水记录也变成了两条，这就没有保证接口的幂等性。</p>
<p> <strong>哪些情况需要防止</strong></p>
<p>​		① 用户多次点击按钮<br>​		② 用户页面回退再次提交<br>​		③ 微服务互相调用， 由于网络问题， 导致请求失败。 feign 触发重试机制<br>​		④ 其他业务情况</p>
<p>什么情况下需要幂等，以 SQL 为例， 有些操作是天然幂等</p>
<p>​		① SELECT * FROM table WHER id&#x3D;?，无论执行多少次都不会改变状态， 是天然的幂等。<br>​		② UPDATE tab1 SET col1&#x3D;1 WHERE col2&#x3D;2，无论执行成功多少次状态都是一致的， 也是幂等操作。<br>​		③ delete from user where userid&#x3D;1，多次操作， 结果一样， 具备幂等性<br>​		④ insert into user(userid,name) values(1,‘a’) 如 userid 为唯一主键，即重复操作上面的业务，只会插入一条用户数据， 具备幂等性。<br>​		⑤ UPDATE tab1 SET col1&#x3D;col1+1 WHERE col2&#x3D;2， 每次执行的结果都会发生变化， 不是幂等的。<br>​		⑥ insert into user(userid,name) values(1,‘a’) 如 userid 不是主键， 可以重复， 那上面业务多次操作， 数据都会新增多条， 不具备幂等性</p>
<h4 id="幂等解决方案"><a href="#幂等解决方案" class="headerlink" title="幂等解决方案"></a><strong>幂等解决方案</strong></h4><h5 id="token-机制"><a href="#token-机制" class="headerlink" title="token 机制"></a>token 机制</h5><p>服务端提供了发送 token 的接口。 我们在分析业务的时候， 哪些业务是存在幂等问题的，就必须在执行业务前， 先去获取 token， 服务器会把 token 保存到 redis 中 。然后调用业务接口请求时， 把 token 携带过去， 一般放在请求头部。服务器判断 token 是否存在 redis 中， 存在表示第一次请求， 然后删除 token，继续执行业务。如果判断 token 不存在 redis 中， 就表示是重复操作， 直接返回重复标记给 client， 这样就保证了业务代码， 不被重复执行。</p>
<p>先删除 token 还是后删除 token?</p>
<p>先删除可能导致，业务确实没有执行，重试还带上之前 token，由于防重设计导致，请求还是不能执行。<br>后删除可能导致，业务处理成功，但是服务闪断， 出现超时，没有删除 token， 别人继续重试，导致业务被执行两遍<br>⚠️我们最好设计为先删除 token，如果业务调用失败， 就重新获取 token 再次请求。</p>
<p>token 获取、 比较和删除必须是原子性</p>
<p>redis.get(token) 、 token.equals、 redis.del(token)如果这两个操作不是原子， 可能导致高并发下， 都 get 到同样的数据， 判断都成功， 继续业务并发执行可以在 redis 使用 lua 脚本完成这个操作</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(‘get’, KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] <span class="keyword">then</span> <span class="keyword">return</span> redis.call(‘del’, KEYS[<span class="number">1</span>]) <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h5 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h5><p><strong>数据库悲观锁</strong><br>select * from xxxx where id &#x3D; 1 for update;<br>悲观锁使用时一般伴随事务一起使用， 数据锁定时间可能会很长， 需要根据实际情况选用。另外要注意的是， id 字段一定是主键或者唯一索引， 不然可能造成锁表的结果， 处理起来会非常麻烦。</p>
<p><strong>数据库乐观锁</strong><br>这种方法适合在 <code>更新</code> 的场景中，<br>update t_goods set count &#x3D; count -1 , version &#x3D; version + 1 where good_id&#x3D;2 and version &#x3D; 1<br>根据 version 版本， 也就是在操作库存前先获取当前商品的 version 版本号， 然后操作的时候带上此 version 号。 我们梳理下， 我们第一次操作库存时， 得到 version 为 1， 调用库存服务version 变成了 2； 但返回给订单服务出现了问题， 订单服务又一次发起调用库存服务， 当订单服务传如的 version 还是 1， 再执行上面的 sql 语句时， 就不会执行； 因为 version 已经变为 2 了， where 条件就不成立。 这样就保证了不管调用几次， 只会真正的处理一次。乐观锁主要使用于处理读多写少的问题</p>
<p><strong>业务层分布式锁</strong><br>如果多个机器可能在同一时间同时处理相同的数据， 比如多台机器定时任务都拿到了相同数据处理， 我们就可以加分布式锁， 锁定此数据， 处理完成后释放锁。 获取到锁的必须先判断这个数据是否被处理过 。</p>
<h5 id="各种唯一约束"><a href="#各种唯一约束" class="headerlink" title="各种唯一约束"></a>各种唯一约束</h5><p>数据库唯一约束<br>插入数据， 应该按照唯一索引进行插入，比如订单号，相同的订单就不可能有两条记录插入。我们在数据库层面防止重复。这个机制是利用了数据库的主键唯一约束的特性，解决了在 insert 场景时幂等问题。 但主键的要求不是自增的主键， 这样就需要业务生成全局唯一的主键。如果是分库分表场景下，路由规则要保证相同请求下，落地在同一个数据库和同一表中，要不然数据库主键约束就不起效果了，因为是不同的数据库和表主键不相关。</p>
<h5 id="redis-set-防重"><a href="#redis-set-防重" class="headerlink" title="redis set 防重"></a>redis set 防重</h5><p>很多数据需要处理，只能被处理一次，比如我们可以计算数据的 MD5 将其放入 redis 的 set，每次处理数据，先看这个 MD5 是否已经存在，存在就不处理。</p>
<h5 id="防重表"><a href="#防重表" class="headerlink" title="防重表"></a>防重表</h5><p>使用订单号 orderNo 做为去重表的唯一索引， 把唯一索引插入去重表， 再进行业务操作， 且他们在同一个事务中。 这个保证了重复请求时， 因为去重表有唯一约束， 导致请求失败， 避免了幂等问题。 这里要注意的是， 去重表和业务表应该在同一库中， 这样就保证了在同一个事务， 即使业务操作失败了， 也会把去重表的数据回滚。 这个很好的保证了数据一致性。之前说的 redis 防重也算</p>
<h5 id="全局请求唯一-id"><a href="#全局请求唯一-id" class="headerlink" title="全局请求唯一 id"></a>全局请求唯一 id</h5><p>调用接口时， 生成一个唯一 id， redis 将数据保存到集合中（去重） ，存在即处理过。可以使用 nginx 设置每一个请求的唯一 id：<code>proxy_set_header X-Request-Id $request_id</code></p>
<h4 id="令牌防止多次提交表单"><a href="#令牌防止多次提交表单" class="headerlink" title="令牌防止多次提交表单"></a>令牌防止多次提交表单</h4> <img src="https://raw.githubusercontent.com/boyiz/OSS/main/img/image-20220911111039667.png" alt="image-20220911111039667" style="zoom:80%;" />

<p><img src="https://raw.githubusercontent.com/boyiz/OSS/main/img/ae4e14cebc5b4a83b950ce0e4b4e74c1.png" alt="提交订单的整体逻辑"></p>
 <img src="https://raw.githubusercontent.com/boyiz/OSS/main/img/image-20220911111408454.png" alt="image-20220911111408454" style="zoom:70%;" />

<h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><h3 id="本地事务"><a href="#本地事务" class="headerlink" title="本地事务"></a>本地事务</h3><p>数据库事务的几个特性： 原子性 、 一致性 、 隔离性和持久性， 简称就是 ACID；</p>
<p>原子性： 一系列的操作整体不可拆分， 要么同时成功， 要么同时失败<br>一致性： 数据在事务的前后， 业务整体一致。<br>隔离性： 事务之间互相隔离。<br>持久性： 一旦事务成功， 数据一定会落盘在数据库</p>
<p>在以往的单体应用中， 我们多个业务操作使用同一条连接操作不同的数据表， 一旦有异常，我们可以很容易的整体回滚比如买东西业务， 扣库存， 下订单， 账户扣款， 是一个整体； 必须同时成功或者失败，一个事务开始， 代表以下的所有操作都在同一个连接里面。</p>
<p><img src="https://raw.githubusercontent.com/boyiz/OSS/main/img/image-20220911111752590.png" alt="image-20220911111752590"></p>
<p>Business： 我们具体的业务代码。Storage： 库存业务代码； 扣库存。Order： 订单业务代码； 保存订单。Account： 账号业务代码； 减账户余额</p>
<h4 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h4><p>READ UNCOMMITTED（读未提交）：该隔离级别的事务会读到其它未提交事务的数据， 此现象也称之为脏读。</p>
<p>READ COMMITTED（读提交）：一个事务可以读取另一个已提交的事务， 多次读取会造成不一样的结果， 此现象称为不可重复读问题， Oracle 和 SQL Server 的默认隔离级别。</p>
<p>REPEATABLE READ（ 可重复读）：该隔离级别是 MySQL 默认的隔离级别， 在同一个事务里， select 的结果是事务开始时时间点的状态， 因此， 同样的 select 操作读到的结果会是一致的， 但是， 会有幻读现象。 MySQL的 InnoDB 引擎可以通过 next-key locks 机制（ 参考下文”行锁的算法”一节） 来避免幻读。</p>
<p>SERIALIZABLE（ 序列化）：在该隔离级别下事务都是串行顺序执行的， MySQL 数据库的 InnoDB 引擎会给读操作隐式加一把读共享锁， 从而避免了脏读、 不可重读复读和幻读问题</p>
<h4 id="事务的传播行为"><a href="#事务的传播行为" class="headerlink" title="事务的传播行为"></a>事务的传播行为</h4><p>PROPAGATION_REQUIRED： 如果当前没有事务， 就创建一个新事务， 如果当前存在事务，就加入该事务， 该设置是最常用的设置。</p>
<p>PROPAGATION_SUPPORTS：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。</p>
<p>PROPAGATION_MANDATORY：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。</p>
<p>PROPAGATION_REQUIRES_NEW：创建新事务， 无论当前存不存在事务， 都创建新事务。</p>
<p>PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作， 如果当前存在事务， 就把当前事务挂起</p>
<p>PROPAGATION_NEVER：以非事务方式执行， 如果当前存在事务， 则抛出异常。</p>
<p>PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。</p>
<h4 id="本地事务在分布式下的问题"><a href="#本地事务在分布式下的问题" class="headerlink" title="本地事务在分布式下的问题"></a>本地事务在分布式下的问题</h4><p> <img src="https://raw.githubusercontent.com/boyiz/OSS/main/img/image-20220911112154093.png" alt="image-20220911112154093"></p>
<p>业务描述：创建好订单后，需要进行下单，下单完成后远程调用gulimall-ware库存服务，远程锁库存，库存锁定成功后又需要远程调用gulimall-member服务，远程扣减积分，而且整个过程是处在本地事务@Transactional中的，那么这样会出现怎么样的问题？本地事务能解决什么问题？<br>① 订单服务异常，库存锁定不运行，全部回滚，撤销操作<br>② 库存服务处异常，库存服务事务自治，锁定失败全部回滚，订单感受到，继续回滚</p>
<p>存在的问题：<br>③ 库存服务锁定成功了，但是网络原因返回数据途中出现问题，远程调用超时抛出异常，因此订单回滚，那么就会出现一个问题，库存扣除成功，但是订单没有下单成功。<br>④ 库存服务锁定成功了，库存服务下面的逻辑（远程扣积分）发生故障，订单回滚了，怎么处理 ？</p>
<p>订单服务连接的是订单数据库，这是一个连接，库存服务连接的是库存数据库，这是一个新的连接，会员服务链接的是会员数据库，这也是一个新的连接。远程调用实际上是一个新的连接，会员服务发生异常，库存服务是感知不到的，已经执行成功的请求是不能回滚的。</p>
<p>远程服务假失败：远程服务其实成功了，由于网络故障等没有返回，导致：订单回滚，库存却扣减<br>远程服务执行完成，下面的其他方法出现问题，导致：已执行的远程请求，肯定不能回滚</p>
<p>本地事务只能控制住在同一个连接中的异常，在分布式系统中，A服务远程调用B服务，B服务远程调用C服务，C服务远程调用D服务，任何一个远程服务出现问题，已经成功执行的远程服务没办法通过Transactional来实现事务的回滚，除非这几个服务不是远程服务，操作的是同一个数据库，在同一个连接内。</p>
<p>本地事务在分布式系统下，只能控制住自己数据库的回滚，控制不了其他服务的数据库的回滚。</p>
<p>分布式事务的问题：网络问题+分布式机器（数据库不是同一个）。</p>
<h3 id="分布式事务理论"><a href="#分布式事务理论" class="headerlink" title="分布式事务理论"></a>分布式事务理论</h3><p>为什么有分布式事务<br>分布式系统经常出现的异常：机器宕机、网络异常、消息丢失、消息乱序、数据错误、不可靠的 TCP、存储数据丢失。</p>
<p> <img src="https://raw.githubusercontent.com/boyiz/OSS/main/img/image-20220911114314432.png" alt="image-20220911114314432"></p>
<h4 id="CAP-定理与-BASE-理论"><a href="#CAP-定理与-BASE-理论" class="headerlink" title="CAP 定理与 BASE 理论"></a><strong>CAP</strong> 定理与 <strong>BASE</strong> 理论</h4><h5 id="CAP-定理"><a href="#CAP-定理" class="headerlink" title="CAP 定理"></a>CAP 定理</h5><p>CAP 原则又称 CAP 定理， 指的是在一个分布式系统中。<br>一致性 （Consistency）<br>            在分布式系统中的所有数据备份， 在同一时刻是否都有同样的值。<br>可用性 （Availability）<br>            在集群中一部分节点故障后， 集群整体是否还能响应客户端的读写请求。<br>分区容错性 （Partition tolerance）<br>            大多数分布式系统都分布在多个子网络，每个子网络就叫做一个区 (partition)。<br>            分区容错的意思是， 区间通信可能失败。<br>            比如， 一台服务器放在中国， 另一台服务器放在美国， 这就是两个区， 它们之间可能无法通信。</p>
<p>CAP 原则指的是，这三个要素最多只能同时实现两点，不可能三者兼顾。<img src="https://raw.githubusercontent.com/boyiz/OSS/main/img/image-20220911114519651.png" alt="image-20220911114519651"><br>一般来说，分区容错无法避免，因此可以认为 CAP 的 P 总是成立。CAP 定理告诉我们， 剩下的 C 和 A 无法同时做到。</p>
<p>分布式系统中实现一致性的 raft 算法、paxos。     <a target="_blank" rel="noopener" href="http://thesecretlivesofdata.com/raft/">http://thesecretlivesofdata.com/raft/</a></p>
<p><strong>面临的问题</strong><br>对于多数大型互联网应用的场景，主机众多、部署分散，而且现在的集群规模越来越大，所以节点故障、网络故障是常态，而且要保证服务可用性达到 99.99999%(N 个 9)，即保证 P和A，舍弃C。</p>
<p><strong>BASE 理论</strong><br>是对 CAP 理论的延伸，思想是即使无法做到强一致性(CAP 的一致性就是强一致性)，但可以采用适当的采取弱一致性，即最终一致性。</p>
<p>基本可用(Basically Available)<br>基本可用是指分布式系统在出现故障的时候，允许损失部分可用性(例如响应时间、 功能上的可用性)，允许损失部分可用性。需要注意的是，基本可用绝不等价于系统不可用。</p>
<ul>
<li><p>响应时间上的损失:正常情况下搜索引擎需要在 0.5 秒之内返回给用户相应的查询结果，但由于出现故障(比如系统部分机房发生断电或断网故障)，查询结果的响应时间增加到了 1~2 秒。</p>
</li>
<li><p>功能上的损失:购物网站在购物高峰(如双十一)时，为了保护系统的稳定性，</p>
<p>部分消费者可能会被引导到一个降级页面。</p>
</li>
</ul>
<p>软状态(Soft State)<br>软状态是指允许系统存在中间状态，而该中间状态不会影响系统整体可用性。分布 式存储中一般一份数据会有多个副本，允许不同副本同步的延时就是软状态的体 现。mysql replication 的异步复制也是一种体现。</p>
<p>最终一致性(Eventual Consistency)<br>最终一致性是指系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。弱一致性和强一致性相反，最终一致性是弱一致性的一种特殊情况。</p>
<p><strong>强一致性、弱一致性、最终一致性</strong><br>从客户端角度，多进程并发访问时，更新过的数据在不同进程如何获取的不同策略，决定了 不同的一致性。对于关系型数据库，要求更新过的数据能被后续的访问都能看到，这是强一 致性。如果能容忍后续的部分或者全部访问不到，则是弱一致性。如果经过一段时间后要求 能访问到更新后的数据，则是最终一致性。</p>
<h3 id="分布式事务常见解决方案"><a href="#分布式事务常见解决方案" class="headerlink" title="分布式事务常见解决方案"></a>分布式事务常见解决方案</h3><h4 id="2PC-模式"><a href="#2PC-模式" class="headerlink" title="2PC 模式"></a>2PC 模式</h4><p>数据库支持的 2PC【 2 phase commit 二阶提交】 ， 又叫做 XA Transactions。其中，XA 是一个两阶段提交协议， 该协议分为以下两个阶段：<br>第一阶段： 事务协调器要求每个涉及到事务的数据库预提交(precommit)此操作， 并反映是否可以提交。<br>第二阶段： 事务协调器要求每个数据库提交数据。<br>其中， 如果有任何一个数据库否决此次提交， 那么所有数据库都会被要求回滚它们在此事务中的那部分信息 。<img src="https://raw.githubusercontent.com/boyiz/OSS/main/img/image-20220911115627942.png" alt="image-20220911115627942"></p>
<ul>
<li>XA 协议比较简单， 而且一旦商业数据库实现了 XA 协议， 使用分布式事务的成本也比较低。</li>
<li>XA 性能不理想， 特别是在交易下单链路， 往往并发量很高， XA 无法满足高并发场景</li>
<li>XA 目前在商业数据库支持的比较理想， 在 mysql 数据库中支持的不太理想， mysql 的XA 实现， 没有记录 prepare 阶段日志， 主备切换回导致主库与备库数据不一致。</li>
<li>许多 nosql 也没有支持 XA， 这让 XA 的应用场景变得非常狭隘。</li>
<li>也有3PC，引入了超时机制(无论协调者还是参与者，在向对方发送请求后，若长时间未收到回应则做出相应处理)</li>
</ul>
<h4 id="柔性事务-TCC-事务补偿型方案"><a href="#柔性事务-TCC-事务补偿型方案" class="headerlink" title="柔性事务 - TCC 事务补偿型方案"></a>柔性事务 <strong>- TCC</strong> 事务补偿型方案</h4><p>刚性事务:遵循 ACID 原则，强一致性。<br>柔性事务:遵循 BASE 理论，最终一致性; 与刚性事务不同，柔性事务允许一定时间内，不同节点的数据不一致，但要求最终一致。<br><img src="https://raw.githubusercontent.com/boyiz/OSS/main/img/image-20220911115853413.png" alt="image-20220911115853413"></p>
<p>一阶段 prepare 行为: 调用 自定义 的 prepare 逻辑。<br>二阶段 commit 行为: 调用 自定义 的 commit 逻辑。<br>二阶段 rollback 行为: 调用 自定义 的 rollback 逻辑。<br>所谓 TCC 模式，是指支持把 自定义 的分支事务纳入到全局事务的管理中。<br><img src="https://raw.githubusercontent.com/boyiz/OSS/main/img/image-20220911120012988.png" alt="image-20220911120012988"></p>
<h4 id="柔性事务-最大努力通知型方案"><a href="#柔性事务-最大努力通知型方案" class="headerlink" title="柔性事务 - 最大努力通知型方案"></a>柔性事务 <strong>-</strong> 最大努力通知型方案</h4><p>按规律进行通知，<code>不保证数据一定能通知成功，但会提供可查询操作接口进行核对</code>。这种方案主要用在与第三方系统通讯时，比如：调用微信或支付宝支付后的支付结果通知。这种方案也是结合 MQ 进行实现，例如:通过 MQ 发送 http 请求，设置最大通知次数。达到通 知次数后即不再通知。</p>
<p>案例：银行通知、商户通知等(各大交易业务平台间的商户通知:多次通知、查询校对、对账文件)，支付宝的支付成功异步回调</p>
<h4 id="柔性事务-可靠消息-最终一致性方案-异步确保型"><a href="#柔性事务-可靠消息-最终一致性方案-异步确保型" class="headerlink" title="柔性事务**-可靠消息+**最终一致性方案(异步确保型)"></a>柔性事务**-<strong>可靠消息</strong>+**最终一致性方案(异步确保型)</h4><p>实现：业务处理服务在业务事务提交之前，向实时消息服务请求发送消息，实时消息服务只 记录消息数据，而不是真正的发送。业务处理服务在业务事务提交之后，向实时消息服务确 认发送。只有在得到确认发送指令后，实时消息服务才会真正发送。</p>
<p>防止消息丢失:<br>1、做好消息确认机制 ( <strong>pulisher</strong>，<strong>consumer</strong>【手动 <strong>ack</strong>】)<br>2、每一个发送的消息都在数据库做好记录。定期将失败的消息再次发送一遍</p>
<h4 id="最终一致性库存解锁逻辑"><a href="#最终一致性库存解锁逻辑" class="headerlink" title="最终一致性库存解锁逻辑"></a>最终一致性库存解锁逻辑</h4><p>在高并发场景下，库存的回滚使用 ：柔性事务-最大努力通知型方案 或 柔性事务-可靠消息+最终一致性方案（ 异步确保型）</p>
<p><img src="https://raw.githubusercontent.com/boyiz/OSS/main/img/image-20220911170731636.png" alt="image-20220911170731636"></p>
<h2 id="商城业务：库存解锁"><a href="#商城业务：库存解锁" class="headerlink" title="商城业务：库存解锁"></a>商城业务：库存解锁</h2><h4 id="创建路由交换机和队列"><a href="#创建路由交换机和队列" class="headerlink" title="创建路由交换机和队列"></a>创建路由交换机和队列</h4><p>gulimall-ware服务整合RabbitMQ</p>
<p>① 导入rabbitmq 依赖<br>② appiliation.properties中配置rabbitmq的参数<br>③ 创建路由交换机、队列和绑定关系</p>
<p><img src="https://raw.githubusercontent.com/boyiz/OSS/main/img/image-20220911172005756.png" alt="image-20220911172005756"></p>
<p>库存锁定成功后，会根据路由键 <code>stock.locked</code> 根据交换机<code>stock-event-exchange</code>，交换机找到队列stock.delay.queue，并将消息发送到消息队列，由于这个队列是延时队列，50min之后队列中的消息变成死信，然后按照路由键<code>stock.release</code>根据交换机<code>stock-event-exchange</code>找到队列<code>stock.release.stock.queue</code>，将消息发送到该队列，然后接下来的解锁库存服务就来处理<code>stock.release.stock.queue</code>中的消息，因为这个队列中的信息都是超时的死信。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRabbitConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MessageConverter <span class="title function_">messageConverter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonMessageConverter</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Exchange <span class="title function_">stockEventExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//String name, boolean durable, boolean autoDelete, Map&lt;String, Object&gt; arguments</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TopicExchange</span>(<span class="string">&quot;stock-event-exchange&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">stockReleaseStockQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//String name【名字】, boolean durable【是否持久化】, boolean exclusive【是否排他】, boolean autoDelete【是否自动删除】, Map&lt;String, Object&gt; arguments【参数】</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;stock.release.stock.queue&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">stockDelayQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        Map&lt;String, Object&gt; args = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        args.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, <span class="string">&quot;stock-event-exchange&quot;</span>);</span><br><span class="line">        args.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;stock.release&quot;</span>);</span><br><span class="line">        args.put(<span class="string">&quot;x-message-ttl&quot;</span>, <span class="number">240000</span>);<span class="comment">// 4min</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;stock.delay.queue&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">stockReleaseBinding</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Binding</span>(<span class="string">&quot;stock.release.stock.queue&quot;</span>,</span><br><span class="line">                Binding.DestinationType.QUEUE,</span><br><span class="line">                <span class="string">&quot;stock-event-exchange&quot;</span>,</span><br><span class="line">                <span class="string">&quot;stock.release.#&quot;</span>,</span><br><span class="line">                <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">stockLockedBinding</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Binding</span>(<span class="string">&quot;stock.delay.queue&quot;</span>,</span><br><span class="line">                Binding.DestinationType.QUEUE,</span><br><span class="line">                <span class="string">&quot;stock-event-exchange&quot;</span>,</span><br><span class="line">                <span class="string">&quot;stock.locked&quot;</span>,</span><br><span class="line">                <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="库存自动解锁"><a href="#库存自动解锁" class="headerlink" title="库存自动解锁"></a>库存自动解锁</h4><p>库存解锁的场景 ：</p>
<ul>
<li><p>下订单成功，订单过期没有支付被系统自动取消，被用户手动取消，都要解锁库存。</p>
</li>
<li><p>下订单成功，库存锁定成功，但是接下来的业务调用失败，导致订单回滚，之前锁定的库存就要解锁。</p>
</li>
</ul>
<p>步骤：<br>锁库存——&gt;保存库存工作单——&gt;判断库存是否锁定成功，如果锁定成功保存库存工作单详情，然后将库存锁定成功的消息发给消息队列——&gt;如果有一个没有锁定成功，就要将之前锁定成功的库存全部解锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只要解锁库存的消息失败，一定要告诉服务解锁失败。【启用手动ack】</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlockStock</span><span class="params">(StockLockedTo stockLockedTo)</span> &#123;</span><br><span class="line">   <span class="type">StockDetailTo</span> <span class="variable">detail</span> <span class="operator">=</span> stockLockedTo.getDetail();</span><br><span class="line">   <span class="type">Long</span> <span class="variable">detailId</span> <span class="operator">=</span> detail.getId();</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 去库存锁定工作单详情查询数据库关于这个订单的锁定库存信息</span></span><br><span class="line"><span class="comment">    *     如果没有这个信息，说明库存锁定失败了，这个商品的库存锁定回滚了，就不需要解锁。</span></span><br><span class="line"><span class="comment">    *     如果有这个信息，说明这个商品的库存锁定成功了，由于其他业务的失败导致订单回滚了</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="type">WareOrderTaskDetailEntity</span> <span class="variable">wareOrderTaskDetailEntity</span> <span class="operator">=</span> wareOrderTaskDetailService.getById(detailId);</span><br><span class="line">   <span class="keyword">if</span>(wareOrderTaskDetailEntity!=<span class="literal">null</span>)&#123;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 解锁：判断订单情况</span></span><br><span class="line"><span class="comment">        *    没有这个订单，必须解锁</span></span><br><span class="line"><span class="comment">        *    有这个订单，判断订单状态：</span></span><br><span class="line"><span class="comment">        *          订单状态为已取消，解锁库存，</span></span><br><span class="line"><span class="comment">        *          没取消订单，不用解锁</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="comment">// 库存工作单id</span></span><br><span class="line">       <span class="type">Long</span> <span class="variable">id</span> <span class="operator">=</span> stockLockedTo.getId();</span><br><span class="line">       <span class="type">WareOrderTaskEntity</span> <span class="variable">wareOrderTaskEntity</span> <span class="operator">=</span> wareOrderTaskService.getById(id);</span><br><span class="line">       <span class="comment">//订单号</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">orderSn</span> <span class="operator">=</span> wareOrderTaskEntity.getOrderSn();</span><br><span class="line">       <span class="comment">//根据订单号查询订单的状态</span></span><br><span class="line">       <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> orderFeignService.getOrderStatus(orderSn);</span><br><span class="line">       <span class="keyword">if</span>(r.getCode() == <span class="number">0</span>)&#123;</span><br><span class="line">           <span class="type">OrderVo</span> <span class="variable">data</span> <span class="operator">=</span> r.getData(<span class="keyword">new</span> <span class="title class_">TypeReference</span>&lt;OrderVo&gt;() &#123;&#125;);</span><br><span class="line">           <span class="keyword">if</span>(data == <span class="literal">null</span> || data.getStatus() == OrderStatusEnum.CANCLED.getCode())&#123;</span><br><span class="line">               <span class="comment">//订单不存在 或 订单已经被取消，解锁库存</span></span><br><span class="line">               <span class="keyword">if</span>(wareOrderTaskDetailEntity.getLockStatus() == WareStatusEnum.LOCK_WARE.getCode())&#123;</span><br><span class="line">                   <span class="comment">//当前库存工作单详情，状态1已锁定 但是未解锁才可以解锁</span></span><br><span class="line">                   unLockStock(detail.getSkuId(), detail.getWareId(), detail.getSkuNum(), detailId);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           <span class="comment">//消息拒绝之后重新放到队列，让别人继续消费解锁</span></span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;远程服务失败&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">       <span class="comment">//不需要解锁</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解锁库存的方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> skuId</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> wareId</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> num</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> taskDetailId</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unLockStock</span><span class="params">(Long skuId, Long wareId, Integer num, Long taskDetailId)</span> &#123;</span><br><span class="line">    <span class="comment">//解锁库存</span></span><br><span class="line">    wareSkuDao.unLockStock(skuId, wareId, num);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//更新工作单的状态</span></span><br><span class="line">    <span class="type">WareOrderTaskDetailEntity</span> <span class="variable">taskDetailEntity</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WareOrderTaskDetailEntity</span>();</span><br><span class="line">    taskDetailEntity.setId(taskDetailId);</span><br><span class="line">    taskDetailEntity.setLockStatus(WareStatusEnum.UNLOCK_WARE.getCode());<span class="comment">//变为已解锁</span></span><br><span class="line">    wareOrderTaskDetailService.updateById(taskDetailEntity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>监听 <code>stock.release.stock.queue</code> 队列，对库存进行解锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;stock.release.stock.queue&quot;)</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StockReleaseListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    WareSkuService wareSkuService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleStockLockedRelease</span><span class="params">(StockLockedTo stockLockedTo, Message message, Channel channel)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;收到解锁库存的消息...&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            wareSkuService.unlockStock(stockLockedTo);</span><br><span class="line">            channel.basicAck(message.getMessageProperties().getDeliveryTag(),<span class="literal">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">//消息拒绝之后重新放到队列，让别人继续消费解锁</span></span><br><span class="line">            channel.basicReject(message.getMessageProperties().getDeliveryTag(),<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="定时关单和手动库存解锁"><a href="#定时关单和手动库存解锁" class="headerlink" title="定时关单和手动库存解锁"></a>定时关单和手动库存解锁</h4><p>订单创建成功后，如果30分钟没有支付，那么系统就要自动取消订单</p>
<p>首先订单创建成功后，先给交换机发送一个消息（创建成功的订单消息），交换机通过路由键将消息发送给延时队列，消息30min之后过期，过期的消息会通过交换机和路由键发送给队列<code>order.release.order.queue</code>，从而让没有支付的订单消息关闭。</p>
<p><img src="https://raw.githubusercontent.com/boyiz/OSS/main/img/image-20220911172655147.png" alt="image-20220911172655147"></p>
<p>① 订单创建成功后就会给 <code>order-event-exchange</code>交换机发送消息 ，通过路由键发送给延时队列 <code>order.delay.queue</code>，延时队列中的消息一旦过过期就会通过交换机的路由键发送给 <code>order.release.order.queue</code>队列，从而实现关闭订单。</p>
<p>② 监听 <code>@RabbitListener(queues = “order.release.order.queue”)</code>这个队列中的消息，实现关闭订单功能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;order.release.order.queue&quot;)</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderCloseListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    OrderService orderService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listener</span><span class="params">(OrderEntity orderEntity, Channel channel, Message message)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;收到过期的订单消息：准备关闭订单&quot;</span> + orderEntity.getOrderSn());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            orderService.closeOrder(orderEntity);</span><br><span class="line">            <span class="comment">//TODO 手动调用支付宝收单</span></span><br><span class="line"></span><br><span class="line">            channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="literal">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            channel.basicReject(message.getMessageProperties().getDeliveryTag(), <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>③ 库存解锁在订单解锁之后，只要订单解锁成功了，那么库存解锁时看订单已经关单了，库存就自动解锁了。</p>
<p><img src="https://raw.githubusercontent.com/boyiz/OSS/main/img/image-20220911172800481.png" alt="image-20220911172800481"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;stock.release.stock.queue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StockReleaseListener</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    WareSkuService wareSkuService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleStockLockedRelease</span><span class="params">(StockLockedTo stockLockedTo, Message message, Channel channel)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;订单关闭准备解锁库存...&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            wareSkuService.unlockStock(stockLockedTo);</span><br><span class="line">            channel.basicAck(message.getMessageProperties().getDeliveryTag(),<span class="literal">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            channel.basicReject(message.getMessageProperties().getDeliveryTag(),<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>④ 但是还有一种情况，如果订单创建成功后由于机器卡顿，消息延迟等原因，订单还没解锁，库存解锁就先执行了，那么库存就没办法解锁了，因为已经解锁一次了，就不会走解锁逻辑了：</p>
<p><img src="https://raw.githubusercontent.com/boyiz/OSS/main/img/image-20220911172841227.png" alt="image-20220911172841227"></p>
<p>解决方法：除了订单创建完成后等待它自动解锁库存之外，我们在订单解锁成功后也应该主动的发送一个消息到交换机，交换机通过路由键<code>order.release.other</code>会将消息发送给<code>stock.release.stock.queue</code>队列，从而实现手动解锁库存。</p>
<p><img src="https://raw.githubusercontent.com/boyiz/OSS/main/img/image-20220911172937982.png" alt="image-20220911172937982"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyMQConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 订单释放直接和库存释放进行绑定</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">orderReleaseOtherBingding</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Binding</span>(<span class="string">&quot;stock.release.stock.queue&quot;</span>,</span><br><span class="line">                Binding.DestinationType.QUEUE,</span><br><span class="line">                <span class="string">&quot;order-event-exchange&quot;</span>,</span><br><span class="line">                <span class="string">&quot;order.release.other.#&quot;</span>,</span><br><span class="line">                <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>订单解锁成功后给交换机发送一个消息，交换机通过路由键将消息发送给 <code>stock.release.stock.queue</code>队列，监听这个队列实现库存的解锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">closeOrder</span><span class="params">(OrderEntity entity)</span> &#123;</span><br><span class="line">   <span class="comment">//查询当前这个订单的最新状态</span></span><br><span class="line">   <span class="type">OrderEntity</span> <span class="variable">orderEntity</span> <span class="operator">=</span> getById(entity.getId());</span><br><span class="line">   <span class="keyword">if</span>(orderEntity.getStatus() == OrderStatusEnum.CREATE_NEW.getCode())&#123;</span><br><span class="line">       <span class="type">OrderEntity</span> <span class="variable">update</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderEntity</span>();</span><br><span class="line">       update.setId(entity.getId());</span><br><span class="line">       update.setStatus(OrderStatusEnum.CANCLED.getCode());</span><br><span class="line">       <span class="built_in">this</span>.updateById(update);</span><br><span class="line"></span><br><span class="line">       <span class="type">OrderTo</span> <span class="variable">orderTo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderTo</span>();</span><br><span class="line">       BeanUtils.copyProperties(orderEntity, orderTo);</span><br><span class="line">       <span class="comment">//如果订单创建成功后由于机器卡顿，消息延迟等原因，订单还没解锁但是先执行了，然后这个消息消费完了</span></span><br><span class="line">       <span class="comment">//这是订单解锁了，但是库存永远得不到释放。所以要发送给MQ</span></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//TODO 保证消息一定发送出去，每一个消息都可以做好日志记录（给数据库保存每一个消息的详细信息）</span></span><br><span class="line">           <span class="comment">//TODO 定期扫描数据库将失败的消息再发送一遍。</span></span><br><span class="line">           rabbitTemplate.convertAndSend(<span class="string">&quot;order-event-exchange&quot;</span>, <span class="string">&quot;order.release.other&quot;</span>, orderTo);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           <span class="comment">//TODO 将没法送成功的消息进行重试发送。</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitHandler</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleOrderCloseRelease</span><span class="params">(OrderTo orderTo, Message message, Channel channel)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;订单关闭准备解锁库存...&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        wareSkuService.unlockStock(orderTo);</span><br><span class="line">        channel.basicAck(message.getMessageProperties().getDeliveryTag(),<span class="literal">false</span>);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        channel.basicReject(message.getMessageProperties().getDeliveryTag(),<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * P298 防止订单服务卡顿，导致订单状态消息一直改不了，库存优先到期，查订单状态新建状态，什么都不处理</span></span><br><span class="line"><span class="comment"> * 导致卡顿的订单，永远都不能解锁库存</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> orderTo</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlockStock</span><span class="params">(OrderTo orderTo)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">orderSn</span> <span class="operator">=</span> orderTo.getOrderSn();</span><br><span class="line">    <span class="comment">//查一下最新库存的状态，防止重复解锁库存</span></span><br><span class="line">    <span class="type">WareOrderTaskEntity</span> <span class="variable">task</span> <span class="operator">=</span> wareOrderTaskService.getOrderTaskByOrderSn(orderSn);</span><br><span class="line">    <span class="type">Long</span> <span class="variable">id</span> <span class="operator">=</span> task.getId();</span><br><span class="line">    <span class="comment">//按照工作单找到所有 没有解锁的库存，进行解锁</span></span><br><span class="line">    List&lt;WareOrderTaskDetailEntity&gt; entities = wareOrderTaskDetailService.list(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;WareOrderTaskDetailEntity&gt;()</span><br><span class="line">                    .eq(<span class="string">&quot;task_id&quot;</span>, id)</span><br><span class="line">                    .eq(<span class="string">&quot;lock_status&quot;</span>, WareStatusEnum.LOCK_WARE.getCode()));</span><br><span class="line">    <span class="comment">//Long skuId, Long wareId, Integer num, Long taskDetailId</span></span><br><span class="line">    <span class="keyword">for</span> (WareOrderTaskDetailEntity entity : entities) &#123;</span><br><span class="line">        unLockStock(entity.getSkuId(), entity.getWareId() ,entity.getSkuNum(), entity.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="商城业务-支付"><a href="#商城业务-支付" class="headerlink" title="商城业务 - 支付"></a>商城业务 - 支付</h2><p><a target="_blank" rel="noopener" href="https://open.alipay.com/">支付宝开放平台</a> </p>
<p><a target="_blank" rel="noopener" href="https://opendocs.alipay.com/open/270/106291/">支付宝文档中心</a></p>
<p><a target="_blank" rel="noopener" href="https://opendocs.alipay.com/common/02kkv7">支付宝沙箱</a></p>
<p><a target="_blank" rel="noopener" href="https://opendocs.alipay.com/common/02kipl">支付宝密钥工具</a></p>
<p>支付宝的通用配置类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;alipay&quot;)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AlipayTemplate</span> &#123;</span><br><span class="line">    <span class="comment">//应用ID，您的APPID，收款账号既是您的APPID对应支付宝账号</span></span><br><span class="line">    <span class="keyword">public</span> String app_id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//商户私钥，您的PKCS8格式RSA2私钥</span></span><br><span class="line">    <span class="keyword">public</span> String merchant_private_key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String alipay_public_key;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//服务器[异步通知]页面路径  需http://格式的完整路径，不能加?id=123这类自定义参数，必须外网可以正常访问</span></span><br><span class="line">    <span class="comment">//支付宝会悄悄的给我们发送一个请求，告诉我们支付成功的信息</span></span><br><span class="line">    <span class="keyword">public</span> String notify_url;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//页面跳转同步通知页面路径 需http://格式的完整路径，不能加?id=123这类自定义参数，必须外网可以正常访问</span></span><br><span class="line">    <span class="comment">//同步通知，支付成功，一般跳转到成功页</span></span><br><span class="line">    <span class="keyword">public</span> String return_url;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//签名方式</span></span><br><span class="line">    <span class="keyword">private</span> String sign_type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//字符编码格式</span></span><br><span class="line">    <span class="keyword">private</span> String charset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//订单超时时间【2分钟】</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">timeout</span> <span class="operator">=</span> <span class="string">&quot;2m&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//支付宝网关</span></span><br><span class="line">    <span class="keyword">public</span> String gatewayUrl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">pay</span><span class="params">(PayVo vo)</span> <span class="keyword">throws</span> AlipayApiException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//AlipayClient alipayClient = new DefaultAlipayClient(AlipayTemplate.gatewayUrl, AlipayTemplate.app_id, AlipayTemplate.merchant_private_key, &quot;json&quot;, AlipayTemplate.charset, AlipayTemplate.alipay_public_key, AlipayTemplate.sign_type);</span></span><br><span class="line">        <span class="comment">//1、根据支付宝的配置生成一个支付客户端</span></span><br><span class="line">        <span class="type">AlipayClient</span> <span class="variable">alipayClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultAlipayClient</span>(gatewayUrl,</span><br><span class="line">                app_id, merchant_private_key, <span class="string">&quot;json&quot;</span>,</span><br><span class="line">                charset, alipay_public_key, sign_type);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、创建一个支付请求 //设置请求参数</span></span><br><span class="line">        <span class="type">AlipayTradePagePayRequest</span> <span class="variable">alipayRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AlipayTradePagePayRequest</span>();</span><br><span class="line">        alipayRequest.setReturnUrl(return_url);</span><br><span class="line">        alipayRequest.setNotifyUrl(notify_url);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//商户订单号，商户网站订单系统中唯一订单号，必填</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">out_trade_no</span> <span class="operator">=</span> vo.getOut_trade_no();</span><br><span class="line">        <span class="comment">//付款金额，必填</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">total_amount</span> <span class="operator">=</span> vo.getTotal_amount();</span><br><span class="line">        <span class="comment">//订单名称，必填</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">subject</span> <span class="operator">=</span> vo.getSubject();</span><br><span class="line">        <span class="comment">//商品描述，可空</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">body</span> <span class="operator">=</span> vo.getBody();</span><br><span class="line"></span><br><span class="line">        alipayRequest.setBizContent(<span class="string">&quot;&#123;\&quot;out_trade_no\&quot;:\&quot;&quot;</span> + out_trade_no + <span class="string">&quot;\&quot;,&quot;</span></span><br><span class="line">                + <span class="string">&quot;\&quot;total_amount\&quot;:\&quot;&quot;</span> + total_amount + <span class="string">&quot;\&quot;,&quot;</span></span><br><span class="line">                + <span class="string">&quot;\&quot;subject\&quot;:\&quot;&quot;</span> + subject + <span class="string">&quot;\&quot;,&quot;</span></span><br><span class="line">                + <span class="string">&quot;\&quot;body\&quot;:\&quot;&quot;</span> + body + <span class="string">&quot;\&quot;,&quot;</span></span><br><span class="line">                + <span class="string">&quot;\&quot;timeout_express\&quot;:\&quot;&quot;</span> + timeout + <span class="string">&quot;\&quot;,&quot;</span></span><br><span class="line">                + <span class="string">&quot;\&quot;product_code\&quot;:\&quot;FAST_INSTANT_TRADE_PAY\&quot;&#125;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> alipayClient.pageExecute(alipayRequest).getBody();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//会收到支付宝的响应，响应的是一个页面，只要浏览器显示这个页面，就会自动来到支付宝的收银台页面</span></span><br><span class="line">        System.out.println(<span class="string">&quot;支付宝的响应：&quot;</span> + result);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="商城业务-秒杀功能"><a href="#商城业务-秒杀功能" class="headerlink" title="商城业务 - 秒杀功能"></a>商城业务 - 秒杀功能</h2><h3 id="定时任务-cron表达式"><a href="#定时任务-cron表达式" class="headerlink" title="定时任务 - cron表达式"></a>定时任务 - <strong>cron表达式</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">特殊字符：</span><br><span class="line">，：枚举；</span><br><span class="line">	(cron=&quot;7,9,23 * * * * ?&quot;)：任意时刻的 7,9，23 秒启动这个任务；</span><br><span class="line">-：范围：</span><br><span class="line">	(cron=&quot;7-20 * * * * ?&quot;):任意时刻的 7-20 秒之间，每秒启动一次</span><br><span class="line">*：任意；</span><br><span class="line">	指定位置的任意时刻都可以</span><br><span class="line">/：步长；</span><br><span class="line">	(cron=&quot;7/5 * * * * ?&quot;)：第 7 秒启动，每 5 秒一次；</span><br><span class="line">	(cron=&quot;*/5 * * * * ?&quot;)：任意秒启动，每 5 秒一次；</span><br><span class="line">？：（出现在日和周几的位置）：为了防止日和周冲突，在周和日上如果要写通配符使用?</span><br><span class="line">	(cron=&quot;* * * 1 * ?&quot;)：每月的 1 号，启动这个任务；</span><br><span class="line">L：（出现在日和周的位置）”，</span><br><span class="line">	last：最后一个</span><br><span class="line">	(cron=&quot;* * * ? * 3L&quot;)：每月的最后一个周二</span><br><span class="line">W：</span><br><span class="line">	Work Day：工作日</span><br><span class="line">	(cron=&quot;* * * W * ?&quot;)：每个月的工作日触发</span><br><span class="line">	(cron=&quot;* * * LW * ?&quot;)：每个月的最后一个工作日触发</span><br><span class="line">#：第几个</span><br><span class="line">(cron	=&quot;* * * ? * 5#2&quot;)：每个月的第 2 个周 4</span><br></pre></td></tr></table></figure>

<p>Spring boot整合定时任务</p>
<ul>
<li>@EnableScheduling：开启其实任务</li>
<li>@Scheduled：开启一个定时任务</li>
</ul>
<p>秒杀（高并发）系统关注的问题</p>
<ul>
<li>服务单一职责 + 独立部署<ul>
<li>秒杀服务即使自己扛不住压力，挂掉。不要影响别人。</li>
</ul>
</li>
<li>秒杀链接加密<ul>
<li>防止恶意攻击，模拟秒杀请求，1000次&#x2F;s攻击。</li>
<li>防止链接暴露，自己工作人员，提前秒杀商品。</li>
</ul>
</li>
<li>库存预热 + 快速扣减<ul>
<li>秒杀读多血少。无需内次实时校验库存。我们库存预热，放到redis中。信号量控制进来秒杀的请求。</li>
</ul>
</li>
<li>动静分离<ul>
<li>nginx做好动静分离。保证秒杀和商品详情页的动态请求才打到后端的服务集群。使用CDN网络，分担本集群压力</li>
</ul>
</li>
<li>恶意请求拦截<ul>
<li>识别非法攻击请求并进行拦截，网关层</li>
</ul>
</li>
<li>流量错峰<ul>
<li>使用各种手段，将流量分担到更大宽度的时间点。比如验证码，加入购物车</li>
</ul>
</li>
<li>限流&amp;熔断&amp;降级<ul>
<li>前端限流+后端限流。限制次数，限制总量，快速失败降级运行，熔断隔离防止雪崩</li>
</ul>
</li>
<li>队列削峰<ul>
<li>1万个商品，每个1000件秒杀。双11所有秒杀成功的请求，进入队列，慢慢创建订单，扣减库存即可。</li>
</ul>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://github.com/boyiz">BOYIZ</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://boyiz.github.io/2022/07/25/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/">https://boyiz.github.io/2022/07/25/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://boyiz.github.io" target="_blank">One Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/">谷粒商城</a></div><div class="post_share"><div class="social-share" data-image="https://fastly.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg2.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://raw.githubusercontent.com/boyiz/OSS/main/img/wxpay.jpg" target="_blank"><img class="post-qr-code-img" src="https://raw.githubusercontent.com/boyiz/OSS/main/img/wxpay.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="https://raw.githubusercontent.com/boyiz/OSS/main/img/alipay.JPG" target="_blank"><img class="post-qr-code-img" src="https://raw.githubusercontent.com/boyiz/OSS/main/img/alipay.JPG" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/07/27/Java8%E6%96%B0%E7%89%B9%E6%80%A7/"><img class="prev-cover" src="https://fastly.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg2.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Lambda和Stream</div></div></a></div><div class="next-post pull-right"><a href="/2022/07/19/Docker%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"><img class="next-cover" src="https://fastly.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg2.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Docker各软件安装</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cdn.jsdelivr.net/gh/boyiz/OSS@main/img/avatar.JPG" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">BOYIZ</div><div class="author-info__description">One Blog</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/boyiz"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/boyiz" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">多少学一点。<img src="https://cdn.jsdelivr.net/gh/boyiz/OSS@main/img/bar2.gif"/ style="height:230px;weight:230px"></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85"><span class="toc-number">1.</span> <span class="toc-text">环境安装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gitignore%E6%96%87%E4%BB%B6"><span class="toc-number">2.</span> <span class="toc-text">.gitignore文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84"><span class="toc-number">3.</span> <span class="toc-text">项目结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%88%B6%E6%A8%A1%E5%9D%97%E5%88%9B%E5%BB%BApox-xml"><span class="toc-number">3.1.</span> <span class="toc-text">父模块创建pox.xml</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%86%E5%90%91%E7%94%9F%E6%88%90mapper%EF%BC%8Cdao%EF%BC%8Centity%EF%BC%8Ccontroller%EF%BC%8Cservice"><span class="toc-number">3.2.</span> <span class="toc-text">逆向生成mapper，dao，entity，controller，service</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAcommom%E6%A8%A1%E5%9D%97"><span class="toc-number">3.3.</span> <span class="toc-text">创建commom模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E5%90%88Mybatis-plus"><span class="toc-number">3.4.</span> <span class="toc-text">整合Mybatis-plus</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SpringCloud-Alibaba"><span class="toc-number">4.</span> <span class="toc-text">SpringCloud Alibaba</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%90%AD%E9%85%8D%E7%8E%AF%E5%A2%83"><span class="toc-number">4.1.</span> <span class="toc-text">搭配环境</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Nacos"><span class="toc-number">4.2.</span> <span class="toc-text">Nacos</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85Nacos-Server"><span class="toc-number">4.2.1.</span> <span class="toc-text">下载安装Nacos Server</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0"><span class="toc-number">4.3.</span> <span class="toc-text">配置服务注册与发现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#EnableDiscoveryClient"><span class="toc-number">4.3.1.</span> <span class="toc-text">@EnableDiscoveryClient</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%80%BC%EF%B8%8F%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8%E6%B5%8B%E8%AF%95"><span class="toc-number">4.4.</span> <span class="toc-text">‼️远程调用测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Nacos%E4%BD%9C%E4%B8%BA%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83"><span class="toc-number">4.5.</span> <span class="toc-text">Nacos作为配置中心</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%86%E8%8A%82"><span class="toc-number">4.5.1.</span> <span class="toc-text">细节</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E5%A4%9A%E9%85%8D%E7%BD%AE%E9%9B%86"><span class="toc-number">4.5.2.</span> <span class="toc-text">加载多配置集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AE"><span class="toc-number">4.5.3.</span> <span class="toc-text">服务配置</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SpringCloud-OpenFeign"><span class="toc-number">5.</span> <span class="toc-text">SpringCloud OpenFeign</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Feign-Client"><span class="toc-number">5.1.</span> <span class="toc-text">Feign Client</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#EnableFeignClients"><span class="toc-number">5.1.1.</span> <span class="toc-text">@EnableFeignClients</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FeignClient"><span class="toc-number">5.1.2.</span> <span class="toc-text">@FeignClient</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JSR303"><span class="toc-number">6.</span> <span class="toc-text">JSR303</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%BB%84%E8%A7%A3%E5%86%B3%E6%A0%A1%E9%AA%8C"><span class="toc-number">6.1.</span> <span class="toc-text">分组解决校验</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%A1%E9%AA%8C%E6%B3%A8%E8%A7%A3"><span class="toc-number">6.2.</span> <span class="toc-text">自定义校验注解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E6%A0%A1%E9%AA%8C%E6%B3%A8%E8%A7%A3-ListValue"><span class="toc-number">6.2.1.</span> <span class="toc-text">自定义一个校验注解@ListValue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%A6%E6%9D%9F%E6%A0%A1%E9%AA%8C%E5%99%A8"><span class="toc-number">6.2.2.</span> <span class="toc-text">创建约束校验器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ElasticSearch"><span class="toc-number">7.</span> <span class="toc-text">ElasticSearch</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker%E5%AE%89%E8%A3%85"><span class="toc-number">7.1.</span> <span class="toc-text">Docker安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">7.2.</span> <span class="toc-text">基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Index-%E7%B4%A2%E5%BC%95"><span class="toc-number">7.2.1.</span> <span class="toc-text">Index(索引)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Type-%E7%B1%BB%E5%9E%8B-%E5%B7%B2%E5%BC%83%E7%94%A8"><span class="toc-number">7.2.2.</span> <span class="toc-text">Type(类型) 已弃用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Document-%E6%96%87%E6%A1%A3"><span class="toc-number">7.2.3.</span> <span class="toc-text">Document(文档)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Field-%E5%AD%97%E6%AE%B5"><span class="toc-number">7.2.4.</span> <span class="toc-text">Field(字段)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95-%E6%9C%BA%E5%88%B6"><span class="toc-number">7.2.5.</span> <span class="toc-text">倒排索引 机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">7.2.6.</span> <span class="toc-text">集群的概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E8%AF%8D"><span class="toc-number">7.2.7.</span> <span class="toc-text">分词</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ik%E5%88%86%E8%AF%8D%E5%99%A8"><span class="toc-number">7.2.7.1.</span> <span class="toc-text">ik分词器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Elasticsearch-Rest-Client"><span class="toc-number">7.3.</span> <span class="toc-text">Elasticsearch-Rest-Client</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7"><span class="toc-number">8.</span> <span class="toc-text">JVM性能监控</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86"><span class="toc-number">8.1.</span> <span class="toc-text">堆</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jvisualvm"><span class="toc-number">8.2.</span> <span class="toc-text">jvisualvm</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95"><span class="toc-number">9.</span> <span class="toc-text">压力测试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87"><span class="toc-number">9.1.</span> <span class="toc-text">性能指标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JMeter-Address-Already-in-use-%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3"><span class="toc-number">9.2.</span> <span class="toc-text">JMeter Address Already in use 错误解决</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98"><span class="toc-number">10.</span> <span class="toc-text">缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E5%90%88Redis"><span class="toc-number">10.1.</span> <span class="toc-text">整合Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-RedisTemplate-%E6%93%8D%E4%BD%9C-redis"><span class="toc-number">10.1.1.</span> <span class="toc-text">使用 RedisTemplate 操作 redis</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98"><span class="toc-number">10.2.</span> <span class="toc-text">缓存失效问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-number">10.2.1.</span> <span class="toc-text">缓存穿透</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="toc-number">10.2.2.</span> <span class="toc-text">缓存雪崩</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="toc-number">10.2.3.</span> <span class="toc-text">缓存击穿</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">10.3.</span> <span class="toc-text">缓存数据一致性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%9D%E8%AF%81%E4%B8%80%E8%87%B4%E6%80%A7%E6%A8%A1%E5%BC%8F"><span class="toc-number">10.3.1.</span> <span class="toc-text">保证一致性模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%8C%E5%86%99%E6%A8%A1%E5%BC%8F"><span class="toc-number">10.3.1.1.</span> <span class="toc-text">双写模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%B1%E6%95%88%E6%A8%A1%E5%BC%8F"><span class="toc-number">10.3.1.2.</span> <span class="toc-text">失效模式</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">11.</span> <span class="toc-text">分布式锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E9%94%81"><span class="toc-number">11.1.</span> <span class="toc-text">本地锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E9%98%B6%E6%AE%B5%E4%B8%80"><span class="toc-number">11.2.</span> <span class="toc-text">分布式锁阶段一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E9%98%B6%E6%AE%B5%E4%BA%8C"><span class="toc-number">11.3.</span> <span class="toc-text">分布式锁阶段二</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E9%98%B6%E6%AE%B5%E4%B8%89"><span class="toc-number">11.4.</span> <span class="toc-text">分布式锁阶段三</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E9%98%B6%E6%AE%B5%E5%9B%9B"><span class="toc-number">11.5.</span> <span class="toc-text">分布式锁阶段四</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%9C%80%E7%BB%88%E9%98%B6%E6%AE%B5"><span class="toc-number">11.6.</span> <span class="toc-text">分布式锁最终阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redisson%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">11.7.</span> <span class="toc-text">Redisson分布式锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%EF%BC%88Reentrant-Lock%EF%BC%89"><span class="toc-number">11.7.0.1.</span> <span class="toc-text">可重入锁（Reentrant Lock）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E9%94%81%EF%BC%88ReadWriteLock%EF%BC%89"><span class="toc-number">11.7.0.2.</span> <span class="toc-text">读写锁（ReadWriteLock）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%EF%BC%88Semaphore%EF%BC%89"><span class="toc-number">11.7.0.3.</span> <span class="toc-text">信号量（Semaphore）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%97%AD%E9%94%81%EF%BC%88CountDownLatch%EF%BC%89"><span class="toc-number">11.7.0.4.</span> <span class="toc-text">闭锁（CountDownLatch）</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-Cache"><span class="toc-number">12.</span> <span class="toc-text">Spring Cache</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">13.</span> <span class="toc-text">多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E7%BA%BF%E7%A8%8B%E7%9A%84-4-%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">13.1.</span> <span class="toc-text">初始化线程的 4 种方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">13.2.</span> <span class="toc-text">线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84-4-%E7%A7%8D%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">13.2.1.</span> <span class="toc-text">常见的 4 种线程池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%83%E5%A4%A7%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E"><span class="toc-number">13.2.2.</span> <span class="toc-text">线程池七大参数说明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%B7%A5%E4%BD%9C%E9%A1%BA%E5%BA%8F"><span class="toc-number">13.2.3.</span> <span class="toc-text">线程池工作顺序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CompletableFuture-%E5%BC%82%E6%AD%A5%E7%BC%96%E6%8E%92"><span class="toc-number">13.2.4.</span> <span class="toc-text">CompletableFuture 异步编排</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C"><span class="toc-number">13.2.4.1.</span> <span class="toc-text">创建异步操作</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A4%E8%AF%81%E6%9C%8D%E5%8A%A1"><span class="toc-number">14.</span> <span class="toc-text">认证服务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%80%E9%80%9A%E9%98%BF%E9%87%8C%E4%BA%91%E7%9A%84%E7%9F%AD%E4%BF%A1%E6%9C%8D%E5%8A%A1"><span class="toc-number">14.0.1.</span> <span class="toc-text">开通阿里云的短信服务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B4%E5%90%88%E7%9F%AD%E4%BF%A1%E6%9C%8D%E5%8A%A1"><span class="toc-number">14.0.2.</span> <span class="toc-text">整合短信服务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E9%AA%8C%E8%AF%81%E7%A0%81%E5%B9%B6%E9%98%B2%E5%88%B7"><span class="toc-number">14.0.3.</span> <span class="toc-text">发送验证码并防刷</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OAuth2-0"><span class="toc-number">15.</span> <span class="toc-text">OAuth2.0</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AE%E5%8D%9A%E7%A4%BE%E4%BA%A4%E7%99%BB%E5%BD%95"><span class="toc-number">15.1.</span> <span class="toc-text">微博社交登录</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8Fsession%E9%97%AE%E9%A2%98"><span class="toc-number">16.</span> <span class="toc-text">分布式session问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8JWT"><span class="toc-number">17.</span> <span class="toc-text">使用JWT</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-RabbitMQ"><span class="toc-number">18.</span> <span class="toc-text">消息队列 RabbitMQ</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RabbitMQ%E7%AE%80%E4%BB%8B"><span class="toc-number">18.1.</span> <span class="toc-text">RabbitMQ简介</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Exchange%E7%B1%BB%E5%9E%8B"><span class="toc-number">18.1.1.</span> <span class="toc-text">Exchange类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring-Boot%E6%95%B4%E5%90%88RabbitMQ"><span class="toc-number">18.1.2.</span> <span class="toc-text">Spring Boot整合RabbitMQ</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RabbitMQ%E6%B6%88%E6%81%AF%E7%A1%AE%E8%AE%A4%E6%9C%BA%E5%88%B6"><span class="toc-number">18.2.</span> <span class="toc-text">RabbitMQ消息确认机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E9%9D%A0%E6%8A%B5%E8%BE%BE-ConfirmCallback"><span class="toc-number">18.2.1.</span> <span class="toc-text">可靠抵达 - ConfirmCallback</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E9%9D%A0%E6%8A%B5%E8%BE%BE-ReturnCallback"><span class="toc-number">18.2.2.</span> <span class="toc-text">可靠抵达 - ReturnCallback</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E9%9D%A0%E6%8A%B5%E8%BE%BE-Ack%E6%B6%88%E6%81%AF%E7%A1%AE%E8%AE%A4%E6%9C%BA%E5%88%B6"><span class="toc-number">18.2.3.</span> <span class="toc-text">可靠抵达 - Ack消息确认机制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E7%9A%84TTL-Time-To-Live"><span class="toc-number">18.3.</span> <span class="toc-text">消息的TTL(Time To Live)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dead-Letter-Exchanges-DLX-%E6%AD%BB%E4%BF%A1%E8%B7%AF%E7%94%B1"><span class="toc-number">18.4.</span> <span class="toc-text">Dead Letter Exchanges (DLX) 死信路由</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%B6%E6%97%B6%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0"><span class="toc-number">18.5.</span> <span class="toc-text">延时队列实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E9%98%9F%E5%88%97%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4"><span class="toc-number">18.5.1.</span> <span class="toc-text">设置队列过期时间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E6%B6%88%E6%81%AF%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4"><span class="toc-number">18.5.2.</span> <span class="toc-text">设置消息过期时间</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E5%8F%AF%E9%9D%A0%E6%80%A7"><span class="toc-number">18.6.</span> <span class="toc-text">如何保证消息可靠性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1"><span class="toc-number">18.6.1.</span> <span class="toc-text">消息丢失</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%87%8D%E5%A4%8D"><span class="toc-number">18.6.2.</span> <span class="toc-text">消息重复</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E7%A7%AF%E5%8E%8B"><span class="toc-number">18.6.3.</span> <span class="toc-text">消息积压</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%95%86%E5%9F%8E%E4%B8%9A%E5%8A%A1-%E8%AE%A2%E5%8D%95%E4%B8%9A%E5%8A%A1"><span class="toc-number">19.</span> <span class="toc-text">商城业务 - 订单业务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89%E6%80%A7"><span class="toc-number">19.1.</span> <span class="toc-text">接口幂等性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%82%E7%AD%89%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">19.1.1.</span> <span class="toc-text">幂等解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#token-%E6%9C%BA%E5%88%B6"><span class="toc-number">19.1.1.1.</span> <span class="toc-text">token 机制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%94%81%E6%9C%BA%E5%88%B6"><span class="toc-number">19.1.1.2.</span> <span class="toc-text">锁机制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%84%E7%A7%8D%E5%94%AF%E4%B8%80%E7%BA%A6%E6%9D%9F"><span class="toc-number">19.1.1.3.</span> <span class="toc-text">各种唯一约束</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#redis-set-%E9%98%B2%E9%87%8D"><span class="toc-number">19.1.1.4.</span> <span class="toc-text">redis set 防重</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%98%B2%E9%87%8D%E8%A1%A8"><span class="toc-number">19.1.1.5.</span> <span class="toc-text">防重表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E8%AF%B7%E6%B1%82%E5%94%AF%E4%B8%80-id"><span class="toc-number">19.1.1.6.</span> <span class="toc-text">全局请求唯一 id</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A4%E7%89%8C%E9%98%B2%E6%AD%A2%E5%A4%9A%E6%AC%A1%E6%8F%90%E4%BA%A4%E8%A1%A8%E5%8D%95"><span class="toc-number">19.1.2.</span> <span class="toc-text">令牌防止多次提交表单</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="toc-number">20.</span> <span class="toc-text">分布式事务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E4%BA%8B%E5%8A%A1"><span class="toc-number">20.1.</span> <span class="toc-text">本地事务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">20.1.1.</span> <span class="toc-text">事务的隔离级别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA"><span class="toc-number">20.1.2.</span> <span class="toc-text">事务的传播行为</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E4%BA%8B%E5%8A%A1%E5%9C%A8%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8B%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">20.1.3.</span> <span class="toc-text">本地事务在分布式下的问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%90%86%E8%AE%BA"><span class="toc-number">20.2.</span> <span class="toc-text">分布式事务理论</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CAP-%E5%AE%9A%E7%90%86%E4%B8%8E-BASE-%E7%90%86%E8%AE%BA"><span class="toc-number">20.2.1.</span> <span class="toc-text">CAP 定理与 BASE 理论</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#CAP-%E5%AE%9A%E7%90%86"><span class="toc-number">20.2.1.1.</span> <span class="toc-text">CAP 定理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%B8%B8%E8%A7%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">20.3.</span> <span class="toc-text">分布式事务常见解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2PC-%E6%A8%A1%E5%BC%8F"><span class="toc-number">20.3.1.</span> <span class="toc-text">2PC 模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%94%E6%80%A7%E4%BA%8B%E5%8A%A1-TCC-%E4%BA%8B%E5%8A%A1%E8%A1%A5%E5%81%BF%E5%9E%8B%E6%96%B9%E6%A1%88"><span class="toc-number">20.3.2.</span> <span class="toc-text">柔性事务 - TCC 事务补偿型方案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%94%E6%80%A7%E4%BA%8B%E5%8A%A1-%E6%9C%80%E5%A4%A7%E5%8A%AA%E5%8A%9B%E9%80%9A%E7%9F%A5%E5%9E%8B%E6%96%B9%E6%A1%88"><span class="toc-number">20.3.3.</span> <span class="toc-text">柔性事务 - 最大努力通知型方案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%94%E6%80%A7%E4%BA%8B%E5%8A%A1-%E5%8F%AF%E9%9D%A0%E6%B6%88%E6%81%AF-%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7%E6%96%B9%E6%A1%88-%E5%BC%82%E6%AD%A5%E7%A1%AE%E4%BF%9D%E5%9E%8B"><span class="toc-number">20.3.4.</span> <span class="toc-text">柔性事务**-可靠消息+**最终一致性方案(异步确保型)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7%E5%BA%93%E5%AD%98%E8%A7%A3%E9%94%81%E9%80%BB%E8%BE%91"><span class="toc-number">20.3.5.</span> <span class="toc-text">最终一致性库存解锁逻辑</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%95%86%E5%9F%8E%E4%B8%9A%E5%8A%A1%EF%BC%9A%E5%BA%93%E5%AD%98%E8%A7%A3%E9%94%81"><span class="toc-number">21.</span> <span class="toc-text">商城业务：库存解锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%B7%AF%E7%94%B1%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%92%8C%E9%98%9F%E5%88%97"><span class="toc-number">21.0.1.</span> <span class="toc-text">创建路由交换机和队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%93%E5%AD%98%E8%87%AA%E5%8A%A8%E8%A7%A3%E9%94%81"><span class="toc-number">21.0.2.</span> <span class="toc-text">库存自动解锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E5%85%B3%E5%8D%95%E5%92%8C%E6%89%8B%E5%8A%A8%E5%BA%93%E5%AD%98%E8%A7%A3%E9%94%81"><span class="toc-number">21.0.3.</span> <span class="toc-text">定时关单和手动库存解锁</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%95%86%E5%9F%8E%E4%B8%9A%E5%8A%A1-%E6%94%AF%E4%BB%98"><span class="toc-number">22.</span> <span class="toc-text">商城业务 - 支付</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%95%86%E5%9F%8E%E4%B8%9A%E5%8A%A1-%E7%A7%92%E6%9D%80%E5%8A%9F%E8%83%BD"><span class="toc-number">23.</span> <span class="toc-text">商城业务 - 秒杀功能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1-cron%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">23.1.</span> <span class="toc-text">定时任务 - cron表达式</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/10/29/%E8%A7%A3%E5%86%B3Springboot%20%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98/" title="解决SpringBoot循环依赖问题"><img src="https://fastly.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg3.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="解决SpringBoot循环依赖问题"/></a><div class="content"><a class="title" href="/2022/10/29/%E8%A7%A3%E5%86%B3Springboot%20%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98/" title="解决SpringBoot循环依赖问题">解决SpringBoot循环依赖问题</a><time datetime="2022-10-28T16:00:00.000Z" title="发表于 2022-10-29 00:00:00">2022-10-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/07/27/Java8%E6%96%B0%E7%89%B9%E6%80%A7/" title="Lambda和Stream"><img src="https://fastly.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Lambda和Stream"/></a><div class="content"><a class="title" href="/2022/07/27/Java8%E6%96%B0%E7%89%B9%E6%80%A7/" title="Lambda和Stream">Lambda和Stream</a><time datetime="2022-07-26T16:00:00.000Z" title="发表于 2022-07-27 00:00:00">2022-07-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/07/25/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/" title="谷粒商城"><img src="https://fastly.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="谷粒商城"/></a><div class="content"><a class="title" href="/2022/07/25/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/" title="谷粒商城">谷粒商城</a><time datetime="2022-07-24T16:00:00.000Z" title="发表于 2022-07-25 00:00:00">2022-07-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/07/19/Docker%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/" title="Docker各软件安装"><img src="https://fastly.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Docker各软件安装"/></a><div class="content"><a class="title" href="/2022/07/19/Docker%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/" title="Docker各软件安装">Docker各软件安装</a><time datetime="2022-07-18T16:00:00.000Z" title="发表于 2022-07-19 00:00:00">2022-07-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/07/18/Docker%E9%AB%98%E7%BA%A7%E7%AF%87/" title="Docker高级篇"><img src="https://fastly.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Docker高级篇"/></a><div class="content"><a class="title" href="/2022/07/18/Docker%E9%AB%98%E7%BA%A7%E7%AF%87/" title="Docker高级篇">Docker高级篇</a><time datetime="2022-07-17T16:00:00.000Z" title="发表于 2022-07-18 00:00:00">2022-07-18</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2023 By BOYIZ</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><a>Hi, 客官欢迎光临～</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>